<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Safety Mechanism Tagging Tool</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;1,9..40,400&family=JetBrains+Mono:wght@400;500&display=swap');

  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface-2: #242836;
    --border: #2e3345;
    --text: #e4e6f0;
    --text-dim: #8b8fa3;
    --accent: #6c5ce7;
    --accent-glow: rgba(108, 92, 231, 0.25);
    --tagged: #00cec9;
    --tagged-glow: rgba(0, 206, 201, 0.3);
    --untagged-opacity: 0.35;
    --tagged-opacity: 0.95;
    --warning: #fdcb6e;
    --danger: #e17055;
    --success: #00b894;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'DM Sans', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* --- HEADER --- */
  .header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 16px 28px;
    display: flex;
    align-items: center;
    gap: 20px;
    position: sticky;
    top: 0;
    z-index: 100;
  }

  .header h1 {
    font-size: 16px;
    font-weight: 600;
    letter-spacing: -0.02em;
    white-space: nowrap;
    color: var(--text);
  }

  .header h1 span {
    color: var(--accent);
  }

  .header-controls {
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
  }

  .doc-select {
    flex: 1;
    max-width: 520px;
    padding: 8px 14px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238b8fa3'%3E%3Cpath d='M6 8L1 3h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 12px center;
    padding-right: 32px;
  }

  .doc-select:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  .doc-select option {
    background: var(--surface-2);
    color: var(--text);
  }

  .btn {
    padding: 8px 16px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface-2);
    color: var(--text);
    font-family: inherit;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .btn:hover {
    background: var(--border);
    border-color: var(--text-dim);
  }

  .btn-primary {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }

  .btn-primary:hover {
    background: #5b4bd5;
  }

  .btn-success {
    background: var(--success);
    border-color: var(--success);
    color: #fff;
  }

  .btn-success:hover {
    background: #00a381;
  }

  .review-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-dim);
    cursor: pointer;
    user-select: none;
  }

  .review-toggle input[type="checkbox"] {
    accent-color: var(--success);
    width: 15px;
    height: 15px;
    cursor: pointer;
  }

  /* --- LAYOUT --- */
  .main-layout {
    display: grid;
    grid-template-columns: 1fr 320px;
    height: calc(100vh - 57px);
  }

  /* --- SUNBURST PANEL --- */
  .sunburst-panel {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    position: relative;
    overflow: hidden;
  }

  .sunburst-panel svg {
    max-width: 100%;
    max-height: calc(100vh - 120px);
  }

  .sunburst-panel svg path {
    transition: fill-opacity 0.2s, stroke-width 0.15s;
  }

  .sunburst-panel svg path.technique-arc {
    cursor: pointer;
  }

  .sunburst-panel svg path.technique-arc:hover {
    stroke: var(--tagged);
    stroke-width: 2.5;
  }

  .sunburst-panel svg path.technique-arc.tagged {
    fill-opacity: var(--tagged-opacity) !important;
    stroke: var(--tagged);
    stroke-width: 2;
  }

  .sunburst-panel svg path.technique-arc.untagged {
    fill-opacity: var(--untagged-opacity) !important;
  }

  /* --- DOC INFO BAR --- */
  .doc-info-bar {
    position: absolute;
    top: 16px;
    left: 20px;
    right: 340px;
    display: flex;
    gap: 16px;
    align-items: flex-start;
  }

  .doc-meta {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px 16px;
    font-size: 12px;
    line-height: 1.5;
    max-width: 480px;
    cursor: grab;
    user-select: none;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    transition: box-shadow 0.15s;
  }

  .doc-meta:active {
    cursor: grabbing;
    box-shadow: 0 8px 28px rgba(0,0,0,0.5);
  }

  .doc-meta a {
    cursor: pointer;
  }

  .doc-meta .doc-title {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 4px;
    color: var(--text);
  }

  .doc-meta .doc-detail {
    color: var(--text-dim);
  }

  .doc-meta .doc-detail strong {
    color: var(--text);
    font-weight: 500;
  }

  .doc-models {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-top: 6px;
  }

  .model-chip {
    padding: 2px 8px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 4px;
    font-size: 11px;
    font-family: 'JetBrains Mono', monospace;
    color: var(--text-dim);
  }

  /* --- SIDEBAR --- */
  .sidebar {
    background: var(--surface);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .sidebar-header {
    padding: 16px;
    border-bottom: 1px solid var(--border);
  }

  .sidebar-header h2 {
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .tag-count {
    font-size: 28px;
    font-weight: 300;
    color: var(--tagged);
    font-family: 'JetBrains Mono', monospace;
  }

  .tag-count span {
    font-size: 14px;
    color: var(--text-dim);
    font-weight: 400;
  }

  .sidebar-scroll {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
  }

  .sidebar-scroll::-webkit-scrollbar {
    width: 5px;
  }

  .sidebar-scroll::-webkit-scrollbar-track {
    background: transparent;
  }

  .sidebar-scroll::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 3px;
  }

  .category-group {
    margin-bottom: 16px;
  }

  .category-label {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-dim);
    padding: 4px 0;
    margin-bottom: 4px;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .category-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    display: inline-block;
  }

  .technique-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    border-radius: 5px;
    font-size: 12px;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.15s;
    user-select: none;
  }

  .technique-item:hover {
    background: var(--surface-2);
  }

  .technique-item.tagged {
    color: var(--text);
    background: rgba(0, 206, 201, 0.08);
  }

  .technique-item .check {
    width: 16px;
    height: 16px;
    border: 1.5px solid var(--border);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.15s;
  }

  .technique-item.tagged .check {
    background: var(--tagged);
    border-color: var(--tagged);
  }

  .technique-item.tagged .check::after {
    content: '✓';
    color: #fff;
    font-size: 10px;
    font-weight: 700;
  }

  .technique-item .tech-name {
    flex: 1;
    line-height: 1.3;
  }

  /* --- PROGRESS BAR --- */
  .sidebar-footer {
    padding: 12px 16px;
    border-top: 1px solid var(--border);
    background: var(--surface-2);
  }

  .progress-label {
    font-size: 11px;
    color: var(--text-dim);
    margin-bottom: 6px;
    display: flex;
    justify-content: space-between;
  }

  .progress-bar {
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-bar-fill {
    height: 100%;
    background: var(--success);
    border-radius: 2px;
    transition: width 0.3s;
  }

  /* --- LOADING --- */
  .loading-screen {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--bg);
    z-index: 999;
    gap: 16px;
  }

  .loading-screen .spinner {
    width: 32px;
    height: 32px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-screen p {
    color: var(--text-dim);
    font-size: 13px;
  }

  /* --- TOOLTIP --- */
  .tooltip {
    position: fixed;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 12px;
    pointer-events: none;
    z-index: 200;
    max-width: 260px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    opacity: 0;
    transition: opacity 0.15s;
  }

  .tooltip.visible { opacity: 1; }

  .tooltip .tt-name {
    font-weight: 600;
    margin-bottom: 2px;
  }

  .tooltip .tt-cat {
    color: var(--text-dim);
    font-size: 11px;
  }

  .tooltip .tt-status {
    margin-top: 4px;
    font-size: 11px;
    font-weight: 500;
  }

  .tooltip .tt-status.is-tagged { color: var(--tagged); }
  .tooltip .tt-status.is-untagged { color: var(--text-dim); }

  /* --- NO DOCUMENT STATE --- */
  .no-doc-message {
    text-align: center;
    color: var(--text-dim);
    font-size: 14px;
    padding: 40px;
  }

  .no-doc-message .icon {
    font-size: 36px;
    margin-bottom: 12px;
    opacity: 0.5;
  }

  /* --- NAV BUTTONS --- */
  .nav-buttons {
    display: flex;
    gap: 6px;
  }

  .btn-nav {
    padding: 6px 10px;
    font-size: 16px;
    line-height: 1;
  }

  /* --- STATUS FLASH --- */
  .flash {
    position: fixed;
    top: 70px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 20px;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 500;
    z-index: 300;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }

  .flash.visible { opacity: 1; }

  .flash.flash-tagged {
    background: var(--tagged);
    color: #fff;
  }

  .flash.flash-untagged {
    background: var(--surface-2);
    color: var(--text-dim);
    border: 1px solid var(--border);
  }
</style>
</head>
<body>

<div class="loading-screen" id="loading">
  <div class="spinner"></div>
  <p>Loading data from GitHub…</p>
</div>

<div class="tooltip" id="tooltip">
  <div class="tt-name"></div>
  <div class="tt-cat"></div>
  <div class="tt-status"></div>
</div>

<div class="flash" id="flash"></div>

<div class="header" id="header" style="display:none;">
  <h1>⬡ Technique <span>Tagger</span></h1>
  <div class="header-controls">
    <div class="nav-buttons">
      <button class="btn btn-nav" id="prevDoc" title="Previous document">◀</button>
      <button class="btn btn-nav" id="nextDoc" title="Next document">▶</button>
    </div>
    <select class="doc-select" id="docSelect">
      <option value="">Select a document to begin tagging…</option>
    </select>
    <label class="review-toggle" id="reviewToggle" style="display:none;">
      <input type="checkbox" id="reviewCheck"> Reviewed
    </label>
    <button class="btn" id="btnClearDoc" title="Clear all tags for this document">Clear Tags</button>
    <button class="btn btn-primary" id="btnDownload">↓ Download JSON</button>
  </div>
</div>

<div class="main-layout" id="mainLayout" style="display:none;">
  <div class="sunburst-panel" id="sunburstPanel">
    <div class="doc-info-bar" id="docInfoBar" style="display:none;">
      <div class="doc-meta" id="docMeta"></div>
    </div>
  </div>
  <div class="sidebar">
    <div class="sidebar-header">
      <h2>Tagged Techniques</h2>
      <div class="tag-count" id="tagCount">0 <span>/ 0</span></div>
    </div>
    <div class="sidebar-scroll" id="sidebarList"></div>
    <div class="sidebar-footer">
      <div class="progress-label">
        <span>Documents reviewed</span>
        <span id="progressText">0 / 0</span>
      </div>
      <div class="progress-bar">
        <div class="progress-bar-fill" id="progressFill" style="width:0%"></div>
      </div>
    </div>
  </div>
</div>

<script>
(async function() {
  // ========== DATA LOADING ==========
  const BASE = 'https://raw.githubusercontent.com/sashaagafonoff/LLM-Safety-Mechanisms/main/data';

  let evidence, techniques, categories, techniqueMap, providers;

  try {
    [evidence, techniques, categories, techniqueMap, providers] = await Promise.all([
      fetch(`${BASE}/evidence.json`).then(r => r.json()).then(d => d.sources || d),
      fetch(`${BASE}/techniques.json`).then(r => r.json()),
      fetch(`${BASE}/categories.json`).then(r => r.json()),
      fetch(`${BASE}/model_technique_map.json`).then(r => r.json()),
      fetch(`${BASE}/providers.json`).then(r => r.json())
    ]);
  } catch(e) {
    document.getElementById('loading').innerHTML =
      `<p style="color:var(--danger)">Failed to load data: ${e.message}</p>`;
    return;
  }

  // ========== STATE ==========
  // Deep clone the technique map so we can modify it
  const tagState = JSON.parse(JSON.stringify(techniqueMap));
  // Track which documents have been reviewed
  const reviewedDocs = JSON.parse(localStorage.getItem('tagging-reviewed') || '{}');
  let currentDocId = null;

  // ========== LOOKUPS ==========
  const catLookup = new Map(categories.map(c => [c.id, c]));
  const techLookup = new Map(techniques.map(t => [t.id, t]));
  const providerLookup = new Map(providers.map(p => [p.id, p]));

  // Group techniques by category
  const techByCategory = new Map();
  techniques.forEach(t => {
    const catName = catLookup.get(t.categoryId)?.name || 'Other';
    if (!techByCategory.has(catName)) techByCategory.set(catName, []);
    techByCategory.get(catName).push(t);
  });

  // Generate category colors (matching Observable)
  const categoryNames = categories.map(c => c.name).sort();
  const categoryColors = {};
  const hueStep = 360 / categoryNames.length;
  categoryNames.forEach((name, i) => {
    categoryColors[name] = d3.hsl(i * hueStep, 0.6, 0.55).toString();
  });

  // ========== HELPER: get tags for current doc ==========
  function getDocTags() {
    if (!currentDocId) return [];
    return tagState[currentDocId] || [];
  }

  function isTagged(techniqueId) {
    return getDocTags().some(t => t.techniqueId === techniqueId);
  }

  function toggleTag(techniqueId) {
    if (!currentDocId) return;
    if (!tagState[currentDocId]) tagState[currentDocId] = [];

    const idx = tagState[currentDocId].findIndex(t => t.techniqueId === techniqueId);
    const techName = techLookup.get(techniqueId)?.name || techniqueId;

    if (idx >= 0) {
      tagState[currentDocId].splice(idx, 1);
      showFlash(`− ${techName}`, false);
    } else {
      tagState[currentDocId].push({
        techniqueId: techniqueId,
        confidence: 'High',
        evidence: ['Manual annotation']
      });
      showFlash(`✓ ${techName}`, true);
    }

    updateVisuals();
  }

  // ========== FLASH MESSAGE ==========
  function showFlash(text, tagged) {
    const el = document.getElementById('flash');
    el.textContent = text;
    el.className = `flash visible ${tagged ? 'flash-tagged' : 'flash-untagged'}`;
    clearTimeout(el._timer);
    el._timer = setTimeout(() => el.classList.remove('visible'), 1200);
  }

  // ========== BUILD SUNBURST ==========
  const width = 860;
  const radius = width / 2;
  const innerRadius = 3;
  const ringWidth = (radius - innerRadius) / 2;

  // Build hierarchy data (static - doesn't change per document)
  const hierarchyData = { name: 'Safety Mechanisms', children: [] };
  const techsByCat = new Map();
  techniques.forEach(t => {
    const catName = catLookup.get(t.categoryId)?.name || 'Other';
    if (!techsByCat.has(catName)) techsByCat.set(catName, []);
    techsByCat.get(catName).push(t);
  });

  Array.from(techsByCat.entries()).forEach(([catName, techs]) => {
    const catNode = { name: catName, children: [] };
    techs.forEach(t => {
      catNode.children.push({
        name: t.name,
        value: 1,
        techniqueId: t.id,
        category: catName
      });
    });
    catNode.children.sort((a, b) => a.name.localeCompare(b.name));
    if (catNode.children.length > 0) hierarchyData.children.push(catNode);
  });
  hierarchyData.children.sort((a, b) => a.name.localeCompare(b.name));

  const hierarchy = d3.hierarchy(hierarchyData)
    .sum(d => d.value || 0)
    .sort((a, b) => a.data.name.localeCompare(b.data.name));

  d3.partition().size([2 * Math.PI, radius])(hierarchy);

  const arc = d3.arc()
    .startAngle(d => d.x0)
    .endAngle(d => d.x1)
    .innerRadius(d => {
      if (d.depth === 0) return 0;
      if (d.depth === 1) return innerRadius;
      return innerRadius + ringWidth;
    })
    .outerRadius(d => {
      if (d.depth === 0) return innerRadius;
      if (d.depth === 1) return innerRadius + ringWidth;
      return radius;
    });

  const color = d3.scaleOrdinal()
    .domain(Object.keys(categoryColors))
    .range(Object.values(categoryColors));

  // Create SVG
  const svg = d3.select('#sunburstPanel')
    .append('svg')
    .attr('viewBox', `${-width/2} ${-width/2} ${width} ${width}`)
    .style('font', '18px "DM Sans", sans-serif');

  const g = svg.selectAll('g.node')
    .data(hierarchy.descendants())
    .join('g')
    .attr('class', 'node');

  // Draw arcs
  g.append('path')
    .attr('fill', d => {
      if (d.depth === 0) return '#1a1d27';
      let node = d;
      while (node.depth > 1) node = node.parent;
      return color(node.data.name);
    })
    .attr('fill-opacity', d => {
      if (d.depth === 0) return 1;
      if (d.depth === 2) return 0.6;
      return 1;
    })
    .attr('stroke', d => d.depth === 0 ? 'var(--border)' : '#1a1d27')
    .attr('stroke-width', 1)
    .attr('d', arc)
    .attr('class', d => d.depth === 2 ? 'technique-arc' : '')
    .attr('data-tech-id', d => d.depth === 2 ? d.data.techniqueId : null)
    .on('click', (event, d) => {
      if (d.depth === 2 && currentDocId) {
        toggleTag(d.data.techniqueId);
      }
    })
    .on('mouseenter', (event, d) => {
      if (d.depth !== 2) return;
      const tooltip = document.getElementById('tooltip');
      tooltip.querySelector('.tt-name').textContent = d.data.name;
      tooltip.querySelector('.tt-cat').textContent = d.data.category;
      const tagged = isTagged(d.data.techniqueId);
      const statusEl = tooltip.querySelector('.tt-status');
      statusEl.textContent = tagged ? '● Tagged — click to remove' : '○ Not tagged — click to add';
      statusEl.className = `tt-status ${tagged ? 'is-tagged' : 'is-untagged'}`;
      tooltip.style.left = (event.clientX + 14) + 'px';
      tooltip.style.top = (event.clientY - 10) + 'px';
      tooltip.classList.add('visible');
    })
    .on('mousemove', (event) => {
      const tooltip = document.getElementById('tooltip');
      tooltip.style.left = (event.clientX + 14) + 'px';
      tooltip.style.top = (event.clientY - 10) + 'px';
    })
    .on('mouseleave', () => {
      document.getElementById('tooltip').classList.remove('visible');
    });

  // Labels
  function wrapText(text, maxChars) {
    if (text.length <= maxChars) return [text];
    const words = text.split(/\s+/);
    const lines = [];
    let cur = '';
    words.forEach(w => {
      if (cur.length + w.length + 1 <= maxChars) {
        cur += (cur.length > 0 ? ' ' : '') + w;
      } else {
        if (cur.length > 0) lines.push(cur);
        cur = w;
      }
    });
    if (cur.length > 0) lines.push(cur);
    return lines;
  }

  g.append('g')
    .attr('class', 'label')
    .style('pointer-events', 'none')
    .attr('transform', d => {
      if (d.depth === 0) return '';
      const angle = (d.x0 + d.x1) / 2;
      const degrees = (angle * 180) / Math.PI - 90;
      let labelRadius = d.depth === 1
        ? innerRadius + ringWidth * 0.55
        : innerRadius + ringWidth * 1.05;
      return `rotate(${degrees}) translate(${labelRadius},0)`;
    })
    .each(function(d) {
      if (d.depth === 0) return;
      const group = d3.select(this);
      const angle = (d.x0 + d.x1) / 2;
      const isRightSide = angle < Math.PI;
      const segmentAngle = d.x1 - d.x0;
      if (segmentAngle < 0.005) return;

      if (d.depth === 1) {
        group.append('text')
          .attr('transform', angle >= Math.PI ? 'rotate(180)' : '')
          .attr('text-anchor', 'middle')
          .attr('dy', '0.35em')
          .style('font-size', '10px')
          .style('font-weight', '600')
          .style('fill', '#fff')
          .text(d.data.name);
      } else {
        const lines = wrapText(d.data.name, 36);
        lines.forEach((line, i) => {
          group.append('text')
            .attr('transform', angle >= Math.PI ? 'rotate(180)' : '')
            .attr('text-anchor', isRightSide ? 'start' : 'end')
            .attr('dy', `${(i - lines.length / 2 + 0.75) * 1.1}em`)
            .attr('x', 0)
            .style('font-size', '11px')
            .style('fill', '#e4e6f0')
            .text(line);
        });
      }
    });

  // ========== BUILD SIDEBAR LIST ==========
  function buildSidebar() {
    const container = document.getElementById('sidebarList');
    container.innerHTML = '';

    const sortedCats = Array.from(techsByCat.entries()).sort((a, b) => a[0].localeCompare(b[0]));

    sortedCats.forEach(([catName, techs]) => {
      const group = document.createElement('div');
      group.className = 'category-group';

      const label = document.createElement('div');
      label.className = 'category-label';
      label.innerHTML = `<span class="category-dot" style="background:${categoryColors[catName]}"></span>${catName}`;
      group.appendChild(label);

      techs.sort((a, b) => a.name.localeCompare(b.name)).forEach(t => {
        const item = document.createElement('div');
        item.className = 'technique-item';
        item.dataset.techId = t.id;
        item.innerHTML = `<div class="check"></div><div class="tech-name">${t.name}</div>`;
        item.addEventListener('click', () => {
          if (currentDocId) toggleTag(t.id);
        });
        group.appendChild(item);
      });

      container.appendChild(group);
    });
  }

  // ========== POPULATE DOC SELECT ==========
  const docSelect = document.getElementById('docSelect');

  // Group evidence by provider
  const evidenceByProvider = new Map();
  evidence.forEach(doc => {
    const provName = providerLookup.get(doc.provider)?.name || doc.provider;
    if (!evidenceByProvider.has(provName)) evidenceByProvider.set(provName, []);
    evidenceByProvider.get(provName).push(doc);
  });

  Array.from(evidenceByProvider.entries())
    .sort((a, b) => a[0].localeCompare(b[0]))
    .forEach(([provName, docs]) => {
      const optgroup = document.createElement('optgroup');
      optgroup.label = provName;
      docs.sort((a, b) => a.title.localeCompare(b.title)).forEach(doc => {
        const opt = document.createElement('option');
        opt.value = doc.id;
        const tagCount = (tagState[doc.id] || []).length;
        const reviewed = reviewedDocs[doc.id] ? ' ✓' : '';
        opt.textContent = `${doc.title} [${tagCount}]${reviewed}`;
        optgroup.appendChild(opt);
      });
      docSelect.appendChild(optgroup);
    });

  // ========== SELECT DOCUMENT ==========
  function selectDocument(docId) {
    currentDocId = docId;
    const doc = evidence.find(d => d.id === docId);

    if (!doc) {
      document.getElementById('docInfoBar').style.display = 'none';
      document.getElementById('reviewToggle').style.display = 'none';
      currentDocId = null;
      updateVisuals();
      return;
    }

    // Show doc info
    const infoBar = document.getElementById('docInfoBar');
    infoBar.style.display = 'flex';

    const provName = providerLookup.get(doc.provider)?.name || doc.provider;
    const modelsHtml = (doc.models || []).map(m =>
      `<span class="model-chip">${m.name || m.modelId}</span>`
    ).join('');

    document.getElementById('docMeta').innerHTML = `
      <div class="doc-title">${doc.title}</div>
      <div class="doc-detail"><strong>Provider:</strong> ${provName} · <strong>Type:</strong> ${doc.type || 'N/A'}</div>
      ${doc.url ? `<div class="doc-detail" style="margin-top:2px"><a href="${doc.url}" target="_blank" style="color:var(--accent);font-size:11px;">Open document ↗</a></div>` : ''}
      ${modelsHtml ? `<div class="doc-models">${modelsHtml}</div>` : ''}
    `;

    // Review checkbox
    const reviewToggle = document.getElementById('reviewToggle');
    reviewToggle.style.display = 'flex';
    document.getElementById('reviewCheck').checked = !!reviewedDocs[docId];

    updateVisuals();
  }

  docSelect.addEventListener('change', () => selectDocument(docSelect.value));

  // Nav buttons
  function getDocList() {
    return Array.from(docSelect.querySelectorAll('option'))
      .filter(o => o.value)
      .map(o => o.value);
  }

  document.getElementById('prevDoc').addEventListener('click', () => {
    const docs = getDocList();
    if (!docs.length) return;
    const idx = docs.indexOf(currentDocId);
    const newIdx = idx <= 0 ? docs.length - 1 : idx - 1;
    docSelect.value = docs[newIdx];
    selectDocument(docs[newIdx]);
  });

  document.getElementById('nextDoc').addEventListener('click', () => {
    const docs = getDocList();
    if (!docs.length) return;
    const idx = docs.indexOf(currentDocId);
    const newIdx = idx >= docs.length - 1 ? 0 : idx + 1;
    docSelect.value = docs[newIdx];
    selectDocument(docs[newIdx]);
  });

  // Review toggle
  document.getElementById('reviewCheck').addEventListener('change', (e) => {
    if (!currentDocId) return;
    if (e.target.checked) {
      reviewedDocs[currentDocId] = true;
    } else {
      delete reviewedDocs[currentDocId];
    }
    localStorage.setItem('tagging-reviewed', JSON.stringify(reviewedDocs));
    updateProgress();
    refreshDocSelect();
  });

  // Clear tags
  document.getElementById('btnClearDoc').addEventListener('click', () => {
    if (!currentDocId) return;
    if (!confirm(`Clear all tags for this document?`)) return;
    tagState[currentDocId] = [];
    updateVisuals();
    refreshDocSelect();
  });

  // ========== DOWNLOAD ==========
  document.getElementById('btnDownload').addEventListener('click', () => {
    // Build clean output - only include entries that have tags
    const output = {};

    // Preserve ALL existing keys from the original map (including empty ones)
    for (const key of Object.keys(techniqueMap)) {
      if (tagState[key] !== undefined) {
        output[key] = tagState[key];
      } else {
        output[key] = techniqueMap[key];
      }
    }

    // Also add any new keys that were tagged
    for (const key of Object.keys(tagState)) {
      if (!(key in output)) {
        output[key] = tagState[key];
      }
    }

    const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'model_technique_map.json';
    a.click();
    URL.revokeObjectURL(url);
  });

  // ========== UPDATE VISUALS ==========
  function updateVisuals() {
    const tags = getDocTags();
    const taggedIds = new Set(tags.map(t => t.techniqueId));

    // Update sunburst arcs
    svg.selectAll('path.technique-arc')
      .classed('tagged', d => currentDocId && taggedIds.has(d.data.techniqueId))
      .classed('untagged', d => currentDocId && !taggedIds.has(d.data.techniqueId))
      // When no doc selected, show neutral state
      .attr('fill-opacity', d => {
        if (!currentDocId) return 0.6;
        return taggedIds.has(d.data.techniqueId) ? 0.95 : 0.35;
      });

    // Update sidebar
    document.querySelectorAll('.technique-item').forEach(item => {
      const techId = item.dataset.techId;
      item.classList.toggle('tagged', taggedIds.has(techId));
    });

    // Update tag count
    document.getElementById('tagCount').innerHTML =
      `${tags.length} <span>/ ${techniques.length}</span>`;

    updateProgress();
  }

  function updateProgress() {
    const total = evidence.length;
    const reviewed = Object.keys(reviewedDocs).length;
    document.getElementById('progressText').textContent = `${reviewed} / ${total}`;
    document.getElementById('progressFill').style.width = `${(reviewed / total) * 100}%`;
  }

  function refreshDocSelect() {
    // Update the option labels to reflect current tag counts
    docSelect.querySelectorAll('option').forEach(opt => {
      if (!opt.value) return;
      const doc = evidence.find(d => d.id === opt.value);
      if (!doc) return;
      const tagCount = (tagState[doc.id] || []).length;
      const reviewed = reviewedDocs[doc.id] ? ' ✓' : '';
      opt.textContent = `${doc.title} [${tagCount}]${reviewed}`;
    });
  }

  // ========== DRAGGABLE DOC INFO ==========
  (function initDrag() {
    const panel = document.getElementById('docMeta');
    let isDragging = false, startX, startY, startLeft, startTop, hasMoved = false;

    panel.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'A') return; // don't drag on links
      isDragging = true;
      hasMoved = false;
      const rect = panel.getBoundingClientRect();
      // Switch to fixed positioning on first drag
      panel.style.position = 'fixed';
      panel.style.left = rect.left + 'px';
      panel.style.top = rect.top + 'px';
      panel.style.zIndex = '150';
      startX = e.clientX;
      startY = e.clientY;
      startLeft = rect.left;
      startTop = rect.top;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      hasMoved = true;
      panel.style.left = (startLeft + e.clientX - startX) + 'px';
      panel.style.top = (startTop + e.clientY - startY) + 'px';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
  })();

  // ========== KEYBOARD SHORTCUTS ==========
  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || (e.key === 'k' && e.ctrlKey)) {
      e.preventDefault();
      document.getElementById('prevDoc').click();
    } else if (e.key === 'ArrowRight' || (e.key === 'j' && e.ctrlKey)) {
      e.preventDefault();
      document.getElementById('nextDoc').click();
    } else if (e.key === 'r' && !e.ctrlKey && !e.metaKey && e.target === document.body) {
      const check = document.getElementById('reviewCheck');
      check.checked = !check.checked;
      check.dispatchEvent(new Event('change'));
    }
  });

  // ========== INIT ==========
  buildSidebar();
  updateProgress();

  document.getElementById('loading').style.display = 'none';
  document.getElementById('header').style.display = 'flex';
  document.getElementById('mainLayout').style.display = 'grid';

})();
</script>
</body>
</html>
