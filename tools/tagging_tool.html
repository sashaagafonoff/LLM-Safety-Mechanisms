<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Safety Mechanism Tagging Tool</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;1,400&family=Overpass+Mono:wght@400;600&family=Source+Sans+3:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap');

  :root {
    --bg: #111318;
    --surface: #191c24;
    --surface-2: #21252f;
    --surface-3: #2a2f3b;
    --border: #2e3445;
    --border-light: #3a4055;
    --text: #d8dbe6;
    --text-dim: #7d829a;
    --text-faint: #555a6e;
    --accent: #5eadf2;
    --accent-dim: rgba(94, 173, 242, 0.15);
    --tagged: #3dd9a0;
    --tagged-dim: rgba(61, 217, 160, 0.12);
    --tagged-border: rgba(61, 217, 160, 0.4);
    --evidence-bg: rgba(61, 217, 160, 0.08);
    --warning: #f0c45a;
    --danger: #e06356;
    --selection-bg: rgba(94, 173, 242, 0.25);
    --selection-border: rgba(94, 173, 242, 0.5);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Source Sans 3', sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* ==================== HEADER ==================== */
  .header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 0 20px;
    height: 50px;
    display: flex;
    align-items: center;
    gap: 14px;
    flex-shrink: 0;
    z-index: 100;
  }

  .logo {
    font-family: 'Overpass Mono', monospace;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 0.08em;
    color: var(--text-dim);
    white-space: nowrap;
    border-right: 1px solid var(--border);
    padding-right: 14px;
  }

  .logo em {
    color: var(--tagged);
    font-style: normal;
  }

  .doc-select-wrap {
    flex: 1;
    max-width: 560px;
    position: relative;
  }

  .doc-select {
    width: 100%;
    padding: 6px 30px 6px 10px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font-family: inherit;
    font-size: 12.5px;
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='%237d829a'%3E%3Cpath d='M5 7L0 2h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
  }

  .doc-select:focus { outline: none; border-color: var(--accent); }
  .doc-select option { background: var(--surface-2); }
  .doc-select optgroup { color: var(--text-dim); font-weight: 600; }

  .nav-group {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .btn {
    height: 30px;
    padding: 0 12px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--surface-2);
    color: var(--text-dim);
    font-family: inherit;
    font-size: 11.5px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.12s;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    gap: 5px;
  }

  .btn:hover { background: var(--surface-3); color: var(--text); border-color: var(--border-light); }
  .btn-nav { padding: 0 7px; font-size: 13px; }
  .btn-save { border-color: var(--tagged-border); color: var(--tagged); }
  .btn-save:hover { background: var(--tagged-dim); }

  .review-label {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-dim);
    cursor: pointer;
    user-select: none;
  }

  .review-label input { accent-color: var(--tagged); width: 14px; height: 14px; cursor: pointer; }

  .header-spacer { flex: 1; }

  .header-stat {
    font-family: 'Overpass Mono', monospace;
    font-size: 11px;
    color: var(--text-dim);
  }

  .header-stat em { font-style: normal; color: var(--tagged); }

  /* ==================== MAIN LAYOUT ==================== */
  .main {
    display: grid;
    grid-template-columns: 1fr 340px;
    flex: 1;
    overflow: hidden;
  }

  /* ==================== DOCUMENT VIEWER ==================== */
  .doc-panel {
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .doc-toolbar {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 8px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    flex-shrink: 0;
    min-height: 38px;
  }

  .doc-toolbar .doc-title-bar {
    font-weight: 500;
    font-size: 13px;
    color: var(--text);
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .doc-toolbar .doc-type-badge {
    font-family: 'Overpass Mono', monospace;
    font-size: 10px;
    padding: 2px 7px;
    background: var(--surface-3);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-dim);
    flex-shrink: 0;
  }

  .doc-toolbar .doc-provider-badge {
    font-size: 11px;
    color: var(--text-dim);
    flex-shrink: 0;
  }

  .doc-toolbar a {
    color: var(--accent);
    font-size: 11px;
    text-decoration: none;
    flex-shrink: 0;
  }

  .doc-toolbar a:hover { text-decoration: underline; }

  .model-chips {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    flex-shrink: 0;
  }

  .model-chip {
    font-family: 'Overpass Mono', monospace;
    font-size: 9.5px;
    padding: 1px 6px;
    background: var(--surface-3);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-dim);
  }

  .doc-content {
    flex: 1;
    overflow-y: auto;
    padding: 28px 40px 80px 40px;
    line-height: 1.75;
    font-family: 'Crimson Pro', serif;
    font-size: 17px;
    color: var(--text);
    cursor: text;
  }

  .doc-content::selection { background: var(--selection-bg); }
  .doc-content *::selection { background: var(--selection-bg); }

  .doc-content::-webkit-scrollbar { width: 7px; }
  .doc-content::-webkit-scrollbar-track { background: transparent; }
  .doc-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

  .doc-empty {
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    color: var(--text-faint);
    font-size: 14px;
    text-align: center;
    padding: 40px;
  }

  .doc-empty .empty-icon { font-size: 32px; margin-bottom: 10px; opacity: 0.4; }
  .doc-empty p { max-width: 340px; line-height: 1.6; }

  /* Evidence highlighting */
  .evidence-highlight {
    background: var(--evidence-bg);
    border-bottom: 2px solid var(--tagged);
    padding: 1px 0;
    cursor: pointer;
    transition: background 0.15s;
    border-radius: 2px;
  }

  .evidence-highlight:hover {
    background: rgba(61, 217, 160, 0.18);
  }

  .evidence-highlight .ev-tag {
    display: inline;
    font-family: 'Overpass Mono', monospace;
    font-size: 9px;
    background: var(--tagged);
    color: var(--bg);
    padding: 1px 4px;
    border-radius: 2px;
    margin-left: 3px;
    vertical-align: super;
    cursor: pointer;
    font-weight: 600;
  }

  /* Selection hint */
  .selection-hint {
    position: fixed;
    background: var(--surface-2);
    border: 1px solid var(--selection-border);
    border-radius: 5px;
    padding: 5px 10px;
    font-size: 11px;
    color: var(--accent);
    pointer-events: none;
    z-index: 200;
    opacity: 0;
    transition: opacity 0.15s;
    font-family: 'Source Sans 3', sans-serif;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }

  .selection-hint.visible { opacity: 1; }

  /* ==================== SIDEBAR ==================== */
  .sidebar {
    background: var(--surface);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .sidebar-header {
    padding: 12px 14px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .sidebar-header h2 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-dim);
  }

  .tag-counter {
    font-family: 'Overpass Mono', monospace;
    font-size: 12px;
    color: var(--tagged);
  }

  .tag-counter span { color: var(--text-faint); }

  .sidebar-scroll {
    flex: 1;
    overflow-y: auto;
    padding: 8px 0;
  }

  .sidebar-scroll::-webkit-scrollbar { width: 5px; }
  .sidebar-scroll::-webkit-scrollbar-track { background: transparent; }
  .sidebar-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .cat-group { margin-bottom: 6px; }

  .cat-header {
    padding: 6px 14px 4px;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-faint);
    display: flex;
    align-items: center;
    gap: 6px;
    position: sticky;
    top: 0;
    background: var(--surface);
    z-index: 2;
  }

  .cat-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .tech-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 5px 14px 5px 14px;
    cursor: pointer;
    transition: background 0.1s;
    user-select: none;
    position: relative;
  }

  .tech-item:hover { background: var(--surface-2); }

  .tech-item.tagged {
    background: var(--tagged-dim);
  }

  .tech-item.tagged:hover {
    background: rgba(61, 217, 160, 0.18);
  }

  .tech-check {
    width: 15px;
    height: 15px;
    border: 1.5px solid var(--border-light);
    border-radius: 3px;
    flex-shrink: 0;
    margin-top: 1px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.12s;
    font-size: 9px;
    color: transparent;
  }

  .tech-item.tagged .tech-check {
    background: var(--tagged);
    border-color: var(--tagged);
    color: var(--bg);
  }

  .tech-body {
    flex: 1;
    min-width: 0;
  }

  .tech-name {
    font-size: 12px;
    line-height: 1.35;
    color: var(--text-dim);
    transition: color 0.1s;
  }

  .tech-item.tagged .tech-name { color: var(--text); }

  .tech-evidence-preview {
    font-size: 10px;
    color: var(--text-faint);
    margin-top: 2px;
    line-height: 1.3;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-family: 'Overpass Mono', monospace;
  }

  .tech-evidence-preview.has-evidence { color: var(--tagged); opacity: 0.7; }
  .tech-evidence-preview.ev-missing { color: var(--warning); opacity: 0.85; }
  .tech-evidence-preview.ev-manual { color: var(--text-faint); }

  .tech-item.tagged.ev-missing-item {
    background: rgba(240, 196, 90, 0.06);
  }

  .tech-evidence-preview.clickable {
    cursor: pointer;
  }

  .tech-evidence-preview.clickable:hover {
    opacity: 1;
    text-decoration: underline;
  }

  /* Scroll-target pulse on evidence highlight */
  @keyframes ev-pulse {
    0% { box-shadow: 0 0 0 0 rgba(61, 217, 160, 0.5); }
    50% { box-shadow: 0 0 0 4px rgba(61, 217, 160, 0.3); }
    100% { box-shadow: 0 0 0 0 rgba(61, 217, 160, 0); }
  }

  .evidence-highlight.pulse {
    animation: ev-pulse 0.8s ease-out 2;
  }

  /* Sidebar item flash on scroll-to */
  @keyframes sidebar-flash {
    0% { outline: 2px solid var(--accent); outline-offset: -1px; }
    100% { outline: 2px solid transparent; outline-offset: -1px; }
  }

  .tech-item.flash-highlight {
    animation: sidebar-flash 1.5s ease-out forwards;
  }

  .tech-info-btn {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    color: var(--text-faint);
    flex-shrink: 0;
    margin-top: 1px;
    cursor: help;
    transition: all 0.12s;
    border: 1px solid transparent;
  }

  .tech-info-btn:hover {
    color: var(--accent);
    background: var(--accent-dim);
    border-color: rgba(94, 173, 242, 0.3);
  }

  /* ==================== TECHNIQUE TOOLTIP ==================== */
  .tech-tooltip {
    position: fixed;
    background: var(--surface-2);
    border: 1px solid var(--border-light);
    border-radius: 6px;
    padding: 12px 14px;
    font-size: 12px;
    z-index: 300;
    max-width: 360px;
    box-shadow: 0 8px 28px rgba(0,0,0,0.5);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.12s;
    line-height: 1.5;
  }

  .tech-tooltip.visible { opacity: 1; }

  .tech-tooltip .tt-title {
    font-weight: 600;
    font-size: 13px;
    margin-bottom: 6px;
    color: var(--text);
  }

  .tech-tooltip .tt-section {
    margin-bottom: 6px;
  }

  .tech-tooltip .tt-label {
    font-size: 9.5px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-faint);
    margin-bottom: 2px;
  }

  .tech-tooltip .tt-text {
    color: var(--text-dim);
    font-size: 11.5px;
  }

  .tech-tooltip .tt-anchors {
    display: flex;
    flex-wrap: wrap;
    gap: 3px;
    margin-top: 3px;
  }

  .tech-tooltip .tt-anchor-tag {
    font-family: 'Overpass Mono', monospace;
    font-size: 9.5px;
    padding: 1px 5px;
    background: var(--surface-3);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-dim);
  }

  /* ==================== SIDEBAR FOOTER ==================== */
  .sidebar-footer {
    padding: 10px 14px;
    border-top: 1px solid var(--border);
    background: var(--surface-2);
  }

  .progress-row {
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    color: var(--text-faint);
    margin-bottom: 5px;
  }

  .progress-bar {
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: var(--tagged);
    border-radius: 2px;
    transition: width 0.3s;
  }

  /* ==================== FLASH MESSAGE ==================== */
  .flash {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 7px 16px;
    border-radius: 5px;
    font-size: 12px;
    font-weight: 500;
    z-index: 300;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }

  .flash.visible { opacity: 1; }
  .flash.flash-tag { background: var(--tagged); color: var(--bg); }
  .flash.flash-untag { background: var(--surface-3); color: var(--text-dim); border: 1px solid var(--border); }
  .flash.flash-save { background: var(--accent); color: #fff; }
  .flash.flash-error { background: var(--danger); color: #fff; }

  /* ==================== LOADING ==================== */
  .loading-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--bg);
    z-index: 999;
    gap: 14px;
  }

  .spinner {
    width: 24px;
    height: 24px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.7s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-overlay p { color: var(--text-dim); font-size: 12px; }
</style>
</head>
<body>

<div class="loading-overlay" id="loading">
  <div class="spinner"></div>
  <p>Loading project data‚Ä¶</p>
</div>

<div class="tech-tooltip" id="techTooltip"></div>
<div class="selection-hint" id="selectionHint">Click a technique to attach this text as evidence ‚Üí</div>
<div class="flash" id="flash"></div>

<div class="header" id="header" style="display:none;">
  <div class="logo"><em>‚ñ™</em> TAG</div>

  <div class="nav-group">
    <button class="btn btn-nav" id="prevDoc" title="Previous (‚Üê)">‚óÄ</button>
    <button class="btn btn-nav" id="nextDoc" title="Next (‚Üí)">‚ñ∂</button>
  </div>

  <div class="doc-select-wrap">
    <select class="doc-select" id="docSelect">
      <option value="">Select a document‚Ä¶</option>
    </select>
  </div>

  <label class="review-label" id="reviewWrap" style="display:none;">
    <input type="checkbox" id="reviewCheck"> Reviewed
  </label>

  <div class="header-spacer"></div>

  <div class="header-stat" id="headerStat"></div>

  <button class="btn" id="btnClear" style="display:none;">Clear</button>
  <button class="btn btn-save" id="btnSave">Save</button>
</div>

<div class="main" id="mainLayout" style="display:none;">
  <!-- DOCUMENT PANEL -->
  <div class="doc-panel" id="docPanel">
    <div class="doc-toolbar" id="docToolbar" style="display:none;">
      <span class="doc-title-bar" id="docTitleBar"></span>
      <div class="model-chips" id="modelChips"></div>
      <span class="doc-type-badge" id="docTypeBadge"></span>
      <span class="doc-provider-badge" id="docProvBadge"></span>
      <a href="#" id="docLink" target="_blank" style="display:none;">Open ‚Üó</a>
    </div>
    <div class="doc-empty" id="docEmpty">
      <div>
        <div class="empty-icon">üìÑ</div>
        <p>Select a document from the dropdown to begin reviewing and tagging safety techniques.</p>
        <p style="margin-top:8px;font-size:12px;color:var(--text-faint)">
          Serve this file from the repo root:<br>
          <code style="font-family:'Overpass Mono',monospace;background:var(--surface-2);padding:2px 6px;border-radius:3px;">python -m http.server 8000</code><br>
          Then open <code style="font-family:'Overpass Mono',monospace;background:var(--surface-2);padding:2px 6px;border-radius:3px;">http://localhost:8000/tools/tagging_tool.html</code>
        </p>
      </div>
    </div>
    <div class="doc-content" id="docContent" style="display:none;"></div>
  </div>

  <!-- SIDEBAR -->
  <div class="sidebar">
    <div class="sidebar-header">
      <h2>Techniques</h2>
      <div class="tag-counter" id="tagCounter">0<span> / 0</span></div>
    </div>
    <div class="sidebar-scroll" id="sidebarList"></div>
    <div class="sidebar-footer">
      <div class="progress-row">
        <span>Documents reviewed</span>
        <span id="progressText">0 / 0</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width:0%"></div>
      </div>
    </div>
  </div>
</div>

<script>
(async function() {

  // ========================================================================
  // DATA LOADING ‚Äî uses relative paths from repo root
  // ========================================================================
  const BASE = '../data';

  let evidence, techniques, categories, techniqueMap, providers;

  try {
    [evidence, techniques, categories, techniqueMap, providers] = await Promise.all([
      fetch(`${BASE}/evidence.json`).then(r => { if (!r.ok) throw new Error('evidence.json'); return r.json(); }).then(d => d.sources || d),
      fetch(`${BASE}/techniques.json`).then(r => { if (!r.ok) throw new Error('techniques.json'); return r.json(); }),
      fetch(`${BASE}/categories.json`).then(r => { if (!r.ok) throw new Error('categories.json'); return r.json(); }),
      fetch(`${BASE}/model_technique_map.json`).then(r => { if (!r.ok) throw new Error('model_technique_map.json'); return r.json(); }),
      fetch(`${BASE}/providers.json`).then(r => { if (!r.ok) throw new Error('providers.json'); return r.json(); })
    ]);
  } catch(e) {
    document.getElementById('loading').innerHTML =
      `<p style="color:var(--danger);">Failed to load <strong>${e.message}</strong>.<br>
       Make sure you're serving from the repo root:<br>
       <code style="font-family:monospace">python -m http.server 8000</code></p>`;
    return;
  }

  // ========================================================================
  // NORMALIZE MAP KEYS ‚Üí evidence IDs
  // ========================================================================
  // The NLU pipeline writes map keys as URLs or titles, but we need evidence
  // IDs as canonical keys. Build reverse lookups and re-key the map.

  console.group('[TAG] Data load summary');
  console.log('Evidence sources:', evidence.length, evidence.map(d => d.id));
  console.log('Techniques:', techniques.length);
  console.log('Raw map keys:', Object.keys(techniqueMap));
  console.log('Raw map key count:', Object.keys(techniqueMap).length);
  // Show non-empty entries
  const nonEmpty = Object.entries(techniqueMap).filter(([k,v]) => v && v.length > 0);
  console.log('Non-empty map entries:', nonEmpty.length, nonEmpty.map(([k,v]) => `${k} (${v.length} techs)`));
  console.groupEnd();

  const urlToEvidenceId = new Map();
  const titleToEvidenceId = new Map();
  const evidenceIdSet = new Set();
  evidence.forEach(doc => {
    evidenceIdSet.add(doc.id);
    if (doc.url) urlToEvidenceId.set(doc.url, doc.id);
    if (doc.title) titleToEvidenceId.set(doc.title, doc.id);
  });

  console.group('[TAG] URL ‚Üí ID lookup table');
  urlToEvidenceId.forEach((id, url) => console.log(`  ${url} ‚Üí ${id}`));
  console.groupEnd();

  function resolveMapKey(key) {
    // Already an evidence ID?
    if (evidenceIdSet.has(key)) return key;
    // URL match?
    if (urlToEvidenceId.has(key)) return urlToEvidenceId.get(key);
    // Title match?
    if (titleToEvidenceId.has(key)) return titleToEvidenceId.get(key);
    // Unknown key ‚Äî keep as-is (orphan)
    return key;
  }

  // Re-key the technique map
  const normalizedMap = {};
  const orphanKeys = [];
  console.group('[TAG] Key resolution');
  for (const [key, value] of Object.entries(techniqueMap)) {
    const resolved = resolveMapKey(key);
    const status = resolved === key ? 'ID-match' : evidenceIdSet.has(resolved) ? `RESOLVED ‚Üí ${resolved}` : 'ORPHAN';
    if (value && value.length > 0) {
      console.log(`  ${key} [${value.length} techs] ‚Üí ${status}`);
    }
    if (!evidenceIdSet.has(resolved)) {
      orphanKeys.push(key);
    }
    // Merge if key already exists (e.g. both ID and URL entries for same doc)
    if (normalizedMap[resolved]) {
      const existing = new Set(normalizedMap[resolved].map(t => t.techniqueId));
      value.forEach(entry => {
        if (!existing.has(entry.techniqueId)) {
          normalizedMap[resolved].push(entry);
        }
      });
    } else {
      normalizedMap[resolved] = value;
    }
  }
  console.groupEnd();

  if (orphanKeys.length > 0) {
    console.warn('[TAG] ‚ö† Orphan keys (not in evidence.json):', orphanKeys);
  }

  console.group('[TAG] Normalized map summary');
  const normalizedNonEmpty = Object.entries(normalizedMap).filter(([k,v]) => v && v.length > 0);
  console.log('Total keys:', Object.keys(normalizedMap).length, '| Non-empty:', normalizedNonEmpty.length);
  normalizedNonEmpty.forEach(([k,v]) => console.log(`  ${k}: ${v.map(t => t.techniqueId).join(', ')}`));
  console.groupEnd();

  // ========================================================================
  // STATE
  // ========================================================================
  const tagState = JSON.parse(JSON.stringify(normalizedMap));
  const reviewedDocs = JSON.parse(localStorage.getItem('tagging-reviewed') || '{}');
  let currentDocId = null;
  let currentDocText = null;      // raw flat text for current doc
  let pendingSelection = null;    // { text } captured from document selection

  // Flag for save state
  let dirtyCount = 0;  // unsaved changes

  // Evidence match tracking: techId ‚Üí 'matched' | 'unmatched' | 'manual' | null
  const evidenceMatchState = new Map();

  // File handle for File System Access API
  let fileHandle = null;

  // ========================================================================
  // LOOKUPS
  // ========================================================================
  const catLookup = new Map(categories.map(c => [c.id, c]));
  const techLookup = new Map(techniques.map(t => [t.id, t]));
  const providerLookup = new Map(providers.map(p => [p.id, p]));

  const categoryNames = categories.map(c => c.name).sort();
  const categoryColors = {};
  const hueStep = 360 / categoryNames.length;
  categoryNames.forEach((name, i) => {
    categoryColors[name] = d3hsl(i * hueStep, 0.55, 0.5);
  });

  // Minimal HSL helper (avoids needing d3 for this)
  function d3hsl(h, s, l) {
    return `hsl(${h}, ${Math.round(s*100)}%, ${Math.round(l*100)}%)`;
  }

  // Group techniques by category
  const techByCategory = new Map();
  techniques.forEach(t => {
    const catName = catLookup.get(t.categoryId)?.name || 'Other';
    if (!techByCategory.has(catName)) techByCategory.set(catName, []);
    techByCategory.get(catName).push(t);
  });

  // ========================================================================
  // HELPERS
  // ========================================================================
  function getDocTags() {
    if (!currentDocId) return [];
    const tags = tagState[currentDocId] || [];
    console.log(`[TAG] getDocTags("${currentDocId}"): ${tags.length} tags`, tags.length > 0 ? tags.map(t => t.techniqueId) : '(empty)');
    return tags;
  }

  function isTagged(techId) {
    return getDocTags().some(t => t.techniqueId === techId);
  }

  function getTagEntry(techId) {
    return getDocTags().find(t => t.techniqueId === techId);
  }

  function flash(msg, type) {
    const el = document.getElementById('flash');
    el.textContent = msg;
    el.className = `flash visible flash-${type}`;
    clearTimeout(el._t);
    el._t = setTimeout(() => el.classList.remove('visible'), 1500);
  }

  // Normalize text for fuzzy matching: collapse whitespace, lowercase, fix ligatures
  function normalize(text) {
    return text
      .replace(/\ufb01/g, 'fi')    // fi ligature
      .replace(/\ufb02/g, 'fl')    // fl ligature
      .replace(/\ufb00/g, 'ff')    // ff ligature
      .replace(/\ufb03/g, 'ffi')   // ffi ligature
      .replace(/\ufb04/g, 'ffl')   // ffl ligature
      .replace(/[\u2018\u2019\u201A]/g, "'")   // smart quotes
      .replace(/[\u201C\u201D\u201E]/g, '"')
      .replace(/[\u2013\u2014]/g, '-')         // en/em dash
      .replace(/\u2026/g, '...')               // ellipsis
      .replace(/\f/g, ' ')                     // form feed
      .replace(/\s+/g, ' ')
      .trim()
      .toLowerCase();
  }

  // Find best match of a snippet within the full text.
  // Returns { start, end } indices in the original text, or null.
  function findEvidence(fullText, snippet) {
    if (!snippet || !fullText) return null;

    const normFull = normalize(fullText);
    const normSnip = normalize(snippet);

    // Try exact normalized match first
    let idx = normFull.indexOf(normSnip);
    if (idx !== -1) {
      // Map back to original indices
      return mapNormalizedRange(fullText, normFull, idx, idx + normSnip.length);
    }

    // Try with first 80 chars of snippet (handles truncation)
    if (normSnip.length > 80) {
      const prefix = normSnip.substring(0, 80);
      idx = normFull.indexOf(prefix);
      if (idx !== -1) {
        // Extend to roughly the snippet length or end of sentence
        const endIdx = Math.min(idx + normSnip.length + 50, normFull.length);
        return mapNormalizedRange(fullText, normFull, idx, endIdx);
      }
    }

    // Try with first 40 chars
    if (normSnip.length > 40) {
      const prefix = normSnip.substring(0, 40);
      idx = normFull.indexOf(prefix);
      if (idx !== -1) {
        const endIdx = Math.min(idx + normSnip.length + 50, normFull.length);
        return mapNormalizedRange(fullText, normFull, idx, endIdx);
      }
    }

    return null;
  }

  // Map normalized string indices back to original string indices
  function mapNormalizedRange(original, normalized, normStart, normEnd) {
    let normIdx = 0;
    let origStart = -1, origEnd = -1;
    let inWhitespace = false;

    for (let i = 0; i < original.length && normIdx <= normEnd; i++) {
      const ch = original[i];
      const isWS = /\s/.test(ch);

      if (isWS) {
        if (!inWhitespace) {
          // This maps to the single space in normalized
          if (normIdx === normStart) origStart = i;
          normIdx++;
          inWhitespace = true;
        }
        // Additional whitespace chars map to nothing
      } else {
        inWhitespace = false;
        if (normIdx === normStart) origStart = i;
        normIdx++;
      }

      if (normIdx === normEnd && origEnd === -1) {
        origEnd = i + 1;
      }
    }

    if (origStart === -1) return null;
    if (origEnd === -1) origEnd = original.length;

    return { start: origStart, end: origEnd };
  }

  // ========================================================================
  // TOGGLE / EVIDENCE LOGIC
  // ========================================================================
  function toggleTech(techId) {
    if (!currentDocId) return;
    if (!tagState[currentDocId]) tagState[currentDocId] = [];

    const techName = techLookup.get(techId)?.name || techId;
    const existing = tagState[currentDocId].findIndex(t => t.techniqueId === techId);

    if (existing >= 0 && pendingSelection) {
      // Already tagged + text selected ‚Üí update evidence
      tagState[currentDocId][existing].evidence = [pendingSelection.text];
      flash(`‚Üª Updated evidence for ${techName}`, 'tag');
    } else if (existing >= 0) {
      // Already tagged + no selection ‚Üí untag
      tagState[currentDocId].splice(existing, 1);
      flash(`‚àí ${techName}`, 'untag');
    } else {
      // Not tagged ‚Üí tag, with evidence if text is selected
      const evidenceText = pendingSelection ? [pendingSelection.text] : ['Manual annotation'];
      tagState[currentDocId].push({
        techniqueId: techId,
        confidence: 'High',
        evidence: evidenceText
      });
      flash(`‚úì ${techName}`, 'tag');
    }

    pendingSelection = null;
    dirtyCount++;
    updateVisuals();
  }

  // ========================================================================
  // BUILD SIDEBAR
  // ========================================================================
  function buildSidebar() {
    const container = document.getElementById('sidebarList');
    container.innerHTML = '';

    const sorted = Array.from(techByCategory.entries()).sort((a,b) => a[0].localeCompare(b[0]));

    sorted.forEach(([catName, techs]) => {
      const group = document.createElement('div');
      group.className = 'cat-group';

      const header = document.createElement('div');
      header.className = 'cat-header';
      header.innerHTML = `<span class="cat-dot" style="background:${categoryColors[catName]}"></span>${catName}`;
      group.appendChild(header);

      techs.sort((a,b) => a.name.localeCompare(b.name)).forEach(t => {
        const item = document.createElement('div');
        item.className = 'tech-item';
        item.dataset.techId = t.id;

        item.innerHTML = `
          <div class="tech-check">‚úì</div>
          <div class="tech-body">
            <div class="tech-name">${t.name}</div>
            <div class="tech-evidence-preview" data-tech-ev="${t.id}"></div>
          </div>
          <div class="tech-info-btn" data-info="${t.id}" title="View technique details">‚ìò</div>
        `;

        // Click handler ‚Äî checkbox always toggles
        item.querySelector('.tech-check').addEventListener('click', (e) => {
          e.stopPropagation();
          toggleTech(t.id);
        });

        // Name click ‚Äî if tagged with evidence, scroll to it; otherwise toggle
        item.querySelector('.tech-name').addEventListener('click', (e) => {
          e.stopPropagation();
          if (isTagged(t.id) && !pendingSelection) {
            const state = evidenceMatchState.get(t.id);
            if (state === 'matched') {
              scrollToEvidence(t.id);
            } else if (state === 'unmatched') {
              flash(`‚ö† Evidence text not found in document`, 'error');
            }
            // 'manual' ‚Äî do nothing on name click (use checkbox to untag)
          } else {
            toggleTech(t.id);
          }
        });

        // Info button
        item.querySelector('.tech-info-btn').addEventListener('mouseenter', (e) => showTechTooltip(e, t));
        item.querySelector('.tech-info-btn').addEventListener('mouseleave', hideTechTooltip);

        group.appendChild(item);
      });

      container.appendChild(group);
    });
  }

  // ========================================================================
  // TECHNIQUE TOOLTIP
  // ========================================================================
  function showTechTooltip(event, tech) {
    const tip = document.getElementById('techTooltip');
    const nlu = tech.nlu_profile || {};
    const cat = catLookup.get(tech.categoryId);

    let html = `<div class="tt-title">${tech.name}</div>`;

    if (cat) {
      html += `<div class="tt-section"><div class="tt-label">Category</div><div class="tt-text">${cat.name}</div></div>`;
    }

    if (tech.description) {
      html += `<div class="tt-section"><div class="tt-label">Description</div><div class="tt-text">${tech.description}</div></div>`;
    }

    if (nlu.primary_concept) {
      html += `<div class="tt-section"><div class="tt-label">Concept</div><div class="tt-text">${nlu.primary_concept}</div></div>`;
    }

    if (nlu.semantic_anchors && nlu.semantic_anchors.length) {
      html += `<div class="tt-section"><div class="tt-label">Semantic Anchors</div><div class="tt-anchors">`;
      nlu.semantic_anchors.forEach(a => {
        html += `<span class="tt-anchor-tag">${a}</span>`;
      });
      html += `</div></div>`;
    }

    if (nlu.entailment_hypothesis) {
      html += `<div class="tt-section"><div class="tt-label">Hypothesis</div><div class="tt-text" style="font-style:italic;">"${nlu.entailment_hypothesis}"</div></div>`;
    }

    tip.innerHTML = html;
    tip.style.visibility = 'hidden';
    tip.classList.add('visible');

    // Position: to the left of the info button
    const rect = event.target.getBoundingClientRect();
    const tipW = tip.offsetWidth;
    const tipH = tip.offsetHeight;
    let left = rect.left - tipW - 10;
    let top = rect.top - 10;

    // Fallback if no room on left
    if (left < 10) left = rect.right + 10;
    // Keep on screen vertically
    top = Math.max(10, Math.min(top, window.innerHeight - tipH - 10));
    tip.style.left = left + 'px';
    tip.style.top = top + 'px';
    tip.style.visibility = '';
  }

  function hideTechTooltip() {
    document.getElementById('techTooltip').classList.remove('visible');
  }

  // ========================================================================
  // DOCUMENT SELECT
  // ========================================================================
  const docSelect = document.getElementById('docSelect');

  // Group by provider
  const evidenceByProvider = new Map();
  evidence.forEach(doc => {
    const provName = providerLookup.get(doc.provider)?.name || doc.provider;
    if (!evidenceByProvider.has(provName)) evidenceByProvider.set(provName, []);
    evidenceByProvider.get(provName).push(doc);
  });

  Array.from(evidenceByProvider.entries())
    .sort((a,b) => a[0].localeCompare(b[0]))
    .forEach(([provName, docs]) => {
      const og = document.createElement('optgroup');
      og.label = provName;
      docs.sort((a,b) => a.title.localeCompare(b.title)).forEach(doc => {
        const opt = document.createElement('option');
        opt.value = doc.id;
        opt.textContent = formatOptionLabel(doc);
        og.appendChild(opt);
      });
      docSelect.appendChild(og);
    });

  function formatOptionLabel(doc) {
    const tagCount = (tagState[doc.id] || []).length;
    const rev = reviewedDocs[doc.id] ? ' ‚úì' : '';
    return `${doc.title}  [${tagCount}]${rev}`;
  }

  function refreshSelectLabels() {
    docSelect.querySelectorAll('option').forEach(opt => {
      if (!opt.value) return;
      const doc = evidence.find(d => d.id === opt.value);
      if (doc) opt.textContent = formatOptionLabel(doc);
    });
  }

  // ========================================================================
  // SELECT DOCUMENT
  // ========================================================================
  async function selectDocument(docId) {
    currentDocId = docId;
    currentDocText = null;
    pendingSelection = null;

    console.group(`[TAG] selectDocument("${docId}")`);
    console.log('tagState has key?', docId in tagState);
    console.log('tagState[docId]:', tagState[docId]);
    console.log('All tagState keys:', Object.keys(tagState));

    const doc = evidence.find(d => d.id === docId);

    if (!doc) {
      document.getElementById('docToolbar').style.display = 'none';
      document.getElementById('docContent').style.display = 'none';
      document.getElementById('docEmpty').style.display = 'flex';
      document.getElementById('reviewWrap').style.display = 'none';
      document.getElementById('btnClear').style.display = 'none';
      updateVisuals();
      return;
    }

    // Show toolbar
    const toolbar = document.getElementById('docToolbar');
    toolbar.style.display = 'flex';
    document.getElementById('btnClear').style.display = '';
    document.getElementById('reviewWrap').style.display = 'flex';
    document.getElementById('reviewCheck').checked = !!reviewedDocs[docId];

    document.getElementById('docTitleBar').textContent = doc.title;
    document.getElementById('docTypeBadge').textContent = doc.type || 'N/A';
    const provName = providerLookup.get(doc.provider)?.name || doc.provider;
    document.getElementById('docProvBadge').textContent = provName;

    const link = document.getElementById('docLink');
    if (doc.url) {
      link.href = doc.url;
      link.style.display = '';
    } else {
      link.style.display = 'none';
    }

    const chips = document.getElementById('modelChips');
    chips.innerHTML = (doc.models || []).map(m =>
      `<span class="model-chip">${m.name || m.modelId}</span>`
    ).join('');

    // Load flat text
    const content = document.getElementById('docContent');
    const empty = document.getElementById('docEmpty');

    try {
      const resp = await fetch(`${BASE}/flat_text/${docId}.txt`);
      if (!resp.ok) throw new Error('not found');
      currentDocText = await resp.text();
      content.style.display = '';
      empty.style.display = 'none';
      renderDocument();
    } catch(e) {
      currentDocText = null;
      content.style.display = 'none';
      empty.style.display = 'flex';
      empty.innerHTML = `<div>
        <div class="empty-icon">‚ö†Ô∏è</div>
        <p>No flat text file found for this document.<br>
        <span style="font-size:12px;color:var(--text-faint);">
          Expected: <code style="font-family:'Overpass Mono',monospace;background:var(--surface-2);padding:2px 6px;border-radius:3px;">/data/flat_text/${docId}.txt</code><br>
          Run <code style="font-family:'Overpass Mono',monospace;background:var(--surface-2);padding:2px 6px;border-radius:3px;">ingest_universal.py</code> to generate it.
        </span></p>
      </div>`;
    }

    console.groupEnd(); // selectDocument
    updateVisuals();
  }

  docSelect.addEventListener('change', () => selectDocument(docSelect.value));

  // ========================================================================
  // RENDER DOCUMENT WITH EVIDENCE HIGHLIGHTING
  // ========================================================================
  function renderDocument() {
    const content = document.getElementById('docContent');

    // Always reset and populate match state, even if no text
    evidenceMatchState.clear();
    const tags = getDocTags();

    console.group(`[TAG] renderDocument: ${tags.length} tags, hasText=${!!currentDocText} (${currentDocText ? currentDocText.length + ' chars' : 'none'})`);

    if (!currentDocText) {
      content.innerHTML = '';
      // Still classify tags for sidebar display
      tags.forEach(tag => {
        const snippets = (tag.evidence || []);
        const hasRealEvidence = snippets.some(s => s !== 'Manual annotation');
        if (!hasRealEvidence) {
          evidenceMatchState.set(tag.techniqueId, 'manual');
        } else {
          evidenceMatchState.set(tag.techniqueId, 'unmatched');
        }
      });
      console.log('No document text loaded, all real evidence marked unmatched');
      console.groupEnd();
      return;
    }

    // Collect all evidence ranges and track match results
    const ranges = [];
    tags.forEach(tag => {
      const tech = techLookup.get(tag.techniqueId);
      if (!tech) {
        console.warn(`  ‚úó techniqueId "${tag.techniqueId}" not found in techniques.json`);
        return;
      }

      const snippets = (tag.evidence || []);
      const hasRealEvidence = snippets.some(s => s !== 'Manual annotation');

      if (!hasRealEvidence) {
        evidenceMatchState.set(tag.techniqueId, 'manual');
        console.log(`  ‚óã ${tech.name}: manual`);
        return;
      }

      let anyMatched = false;
      snippets.forEach(snippet => {
        if (snippet === 'Manual annotation') return;
        const match = findEvidence(currentDocText, snippet);
        if (match) {
          anyMatched = true;
          ranges.push({
            start: match.start,
            end: match.end,
            techId: tag.techniqueId,
            techName: tech.name,
            catName: catLookup.get(tech.categoryId)?.name || ''
          });
          console.log(`  ‚óè ${tech.name}: MATCHED at ${match.start}-${match.end}`);
        } else {
          console.log(`  ‚ö† ${tech.name}: NOT FOUND ‚Äî snippet starts: "${snippet.substring(0, 60)}‚Ä¶"`);
        }
      });

      evidenceMatchState.set(tag.techniqueId, anyMatched ? 'matched' : 'unmatched');
    });

    console.log('Evidence match summary:', Object.fromEntries(evidenceMatchState));
    console.groupEnd();

    // Sort ranges by start position
    ranges.sort((a, b) => a.start - b.start);

    // Build HTML with highlights
    let html = '';
    let cursor = 0;

    // Merge overlapping ranges
    const merged = [];
    ranges.forEach(r => {
      if (merged.length > 0) {
        const last = merged[merged.length - 1];
        if (r.start < last.end) {
          last.end = Math.max(last.end, r.end);
          if (!last.techNames) last.techNames = [last.techName];
          if (!last.techIds) last.techIds = [last.techId];
          last.techNames.push(r.techName);
          last.techIds.push(r.techId);
          return;
        }
      }
      merged.push({ ...r, techNames: [r.techName], techIds: [r.techId] });
    });

    merged.forEach(r => {
      if (r.start > cursor) {
        html += escapeAndFormat(currentDocText.slice(cursor, r.start));
      }

      const labelHtml = r.techNames.map((name, i) =>
        `<span class="ev-tag" data-tech-id="${r.techIds[i]}">${name}</span>`
      ).join('');

      // Add id for each techId so we can scroll to it
      const idAttrs = r.techIds.map(id => `ev-${id}`).join(' ');

      html += `<span class="evidence-highlight" id="ev-${r.techIds[0]}" data-tech-ids="${r.techIds.join(',')}">`
           +  escapeHtml(currentDocText.slice(r.start, r.end))
           +  labelHtml
           +  `</span>`;

      cursor = r.end;
    });

    if (cursor < currentDocText.length) {
      html += escapeAndFormat(currentDocText.slice(cursor));
    }

    content.innerHTML = html;

    // Click on evidence tags in document ‚Üí flash sidebar item
    content.querySelectorAll('.ev-tag').forEach(tag => {
      tag.addEventListener('click', (e) => {
        e.stopPropagation();
        scrollToSidebarItem(tag.dataset.techId);
      });
    });
  }

  function escapeHtml(text) {
    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function escapeAndFormat(text) {
    // Escape HTML and convert double newlines to paragraph breaks
    let html = escapeHtml(text);
    html = html.replace(/\n{2,}/g, '</p><p style="margin-top:12px;">');
    html = html.replace(/\n/g, '<br>');
    return html;
  }

  // ========================================================================
  // SCROLL NAVIGATION
  // ========================================================================
  function scrollToEvidence(techId) {
    const state = evidenceMatchState.get(techId);
    if (state === 'matched') {
      const el = document.getElementById(`ev-${techId}`);
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // Pulse animation
        el.classList.remove('pulse');
        void el.offsetWidth;
        el.classList.add('pulse');

        // Select the evidence text (excluding the tag labels)
        try {
          const sel = window.getSelection();
          sel.removeAllRanges();
          const range = document.createRange();

          // Select only the text nodes, not the ev-tag spans
          const textNodes = [];
          el.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) textNodes.push(node);
          });

          if (textNodes.length > 0) {
            range.setStart(textNodes[0], 0);
            range.setEnd(textNodes[textNodes.length - 1], textNodes[textNodes.length - 1].length);
            sel.addRange(range);
          }
        } catch(e) { /* selection not critical */ }
        return;
      }
    }
    if (state === 'unmatched') {
      flash(`‚ö† Evidence text not found in document`, 'error');
    }
  }

  function scrollToSidebarItem(techId) {
    const item = document.querySelector(`.tech-item[data-tech-id="${techId}"]`);
    if (item) {
      item.scrollIntoView({ behavior: 'smooth', block: 'center' });
      item.classList.remove('flash-highlight');
      void item.offsetWidth;
      item.classList.add('flash-highlight');
    }
  }

  // ========================================================================
  // TEXT SELECTION ‚Üí EVIDENCE CAPTURE
  // ========================================================================
  const selHint = document.getElementById('selectionHint');

  document.getElementById('docContent').addEventListener('mouseup', (e) => {
    const sel = window.getSelection();
    const text = sel.toString().trim();

    if (text.length > 10) {
      pendingSelection = { text };
      selHint.style.left = (e.clientX + 12) + 'px';
      selHint.style.top = (e.clientY - 30) + 'px';
      selHint.classList.add('visible');
    } else {
      pendingSelection = null;
      selHint.classList.remove('visible');
    }
  });

  // Hide hint when clicking outside doc or when selection clears
  document.addEventListener('mousedown', (e) => {
    if (!e.target.closest('.doc-content') && !e.target.closest('.tech-item')) {
      pendingSelection = null;
      selHint.classList.remove('visible');
    }
  });

  // ========================================================================
  // NAV BUTTONS
  // ========================================================================
  function getDocIds() {
    return Array.from(docSelect.querySelectorAll('option'))
      .filter(o => o.value).map(o => o.value);
  }

  document.getElementById('prevDoc').addEventListener('click', () => {
    const ids = getDocIds();
    if (!ids.length) return;
    const idx = ids.indexOf(currentDocId);
    const nIdx = idx <= 0 ? ids.length - 1 : idx - 1;
    docSelect.value = ids[nIdx];
    selectDocument(ids[nIdx]);
  });

  document.getElementById('nextDoc').addEventListener('click', () => {
    const ids = getDocIds();
    if (!ids.length) return;
    const idx = ids.indexOf(currentDocId);
    const nIdx = idx >= ids.length - 1 ? 0 : idx + 1;
    docSelect.value = ids[nIdx];
    selectDocument(ids[nIdx]);
  });

  // ========================================================================
  // REVIEW TOGGLE
  // ========================================================================
  document.getElementById('reviewCheck').addEventListener('change', (e) => {
    if (!currentDocId) return;
    if (e.target.checked) reviewedDocs[currentDocId] = true;
    else delete reviewedDocs[currentDocId];
    localStorage.setItem('tagging-reviewed', JSON.stringify(reviewedDocs));
    updateProgress();
    refreshSelectLabels();
  });

  // ========================================================================
  // CLEAR TAGS
  // ========================================================================
  document.getElementById('btnClear').addEventListener('click', () => {
    if (!currentDocId) return;
    if (!confirm('Clear all tags for this document?')) return;
    tagState[currentDocId] = [];
    dirtyCount++;
    updateVisuals();
    refreshSelectLabels();
  });

  // ========================================================================
  // SAVE ‚Äî File System Access API with download fallback
  // ========================================================================
  document.getElementById('btnSave').addEventListener('click', async () => {
    const output = buildOutput();
    const json = JSON.stringify(output, null, 2);

    // Try File System Access API (Chrome/Edge)
    if ('showSaveFilePicker' in window) {
      try {
        if (!fileHandle) {
          fileHandle = await window.showSaveFilePicker({
            suggestedName: 'model_technique_map.json',
            types: [{
              description: 'JSON files',
              accept: { 'application/json': ['.json'] }
            }]
          });
        }
        const writable = await fileHandle.createWritable();
        await writable.write(json);
        await writable.close();
        dirtyCount = 0;
        flash('Saved to file', 'save');
        return;
      } catch(e) {
        if (e.name === 'AbortError') return; // user cancelled
        // Fall through to download
      }
    }

    // Fallback: download
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'model_technique_map.json';
    a.click();
    URL.revokeObjectURL(url);
    dirtyCount = 0;
    flash('Downloaded model_technique_map.json', 'save');
  });

  function buildOutput() {
    const output = {};
    // Preserve all existing keys from the normalized map
    for (const key of Object.keys(normalizedMap)) {
      output[key] = tagState[key] !== undefined ? tagState[key] : normalizedMap[key];
    }
    // Include new keys added during this session
    for (const key of Object.keys(tagState)) {
      if (!(key in output)) output[key] = tagState[key];
    }
    return output;
  }

  // ========================================================================
  // UPDATE VISUALS
  // ========================================================================
  function updateVisuals() {
    const tags = getDocTags();
    const taggedIds = new Set(tags.map(t => t.techniqueId));

    // Render document FIRST to populate evidenceMatchState
    renderDocument();

    // Sidebar items (now evidenceMatchState is current)
    document.querySelectorAll('.tech-item').forEach(item => {
      const techId = item.dataset.techId;
      const tagged = taggedIds.has(techId);
      item.classList.toggle('tagged', tagged);

      const matchState = evidenceMatchState.get(techId) || null;
      item.classList.toggle('ev-missing-item', tagged && matchState === 'unmatched');

      // Evidence preview line
      const evEl = item.querySelector('.tech-evidence-preview');
      // Remove old click listener by replacing node
      const newEvEl = evEl.cloneNode(true);
      evEl.parentNode.replaceChild(newEvEl, evEl);

      if (tagged && currentDocId) {
        const entry = tags.find(t => t.techniqueId === techId);
        const evText = entry?.evidence?.[0] || '';

        newEvEl.style.display = '';
        newEvEl.className = 'tech-evidence-preview';

        if (matchState === 'matched') {
          // Evidence found in document ‚Äî clickable to scroll
          const preview = evText.substring(0, 55) + (evText.length > 55 ? '‚Ä¶' : '');
          newEvEl.textContent = '‚óè ' + preview;
          newEvEl.classList.add('has-evidence', 'clickable');
          newEvEl.addEventListener('click', (e) => {
            e.stopPropagation();
            scrollToEvidence(techId);
          });
        } else if (matchState === 'unmatched') {
          // Evidence text exists but not found in flat text
          const preview = evText.substring(0, 45) + (evText.length > 45 ? '‚Ä¶' : '');
          newEvEl.textContent = '‚ö† not found: ' + preview;
          newEvEl.classList.add('ev-missing');
        } else if (matchState === 'manual') {
          newEvEl.textContent = '‚óã manual annotation';
          newEvEl.classList.add('ev-manual');
        } else {
          newEvEl.textContent = '';
          newEvEl.style.display = 'none';
        }
      } else {
        newEvEl.style.display = 'none';
        newEvEl.className = 'tech-evidence-preview';
      }
    });

    // Tag counter with match quality
    const matched = tags.filter(t => evidenceMatchState.get(t.techniqueId) === 'matched').length;
    const unmatched = tags.filter(t => evidenceMatchState.get(t.techniqueId) === 'unmatched').length;
    const manual = tags.filter(t => evidenceMatchState.get(t.techniqueId) === 'manual').length;

    let counterHtml = `${tags.length}<span> / ${techniques.length}</span>`;
    if (tags.length > 0 && currentDocId) {
      const parts = [];
      if (matched) parts.push(`<span style="color:var(--tagged)">${matched} found</span>`);
      if (unmatched) parts.push(`<span style="color:var(--warning)">${unmatched} missing</span>`);
      if (manual) parts.push(`<span style="color:var(--text-faint)">${manual} manual</span>`);
      counterHtml += `<br><span style="font-size:10px">${parts.join(' ¬∑ ')}</span>`;
    }
    document.getElementById('tagCounter').innerHTML = counterHtml;

    // Header stat
    const totalTagged = Object.values(tagState).reduce((sum, arr) => sum + (arr?.length || 0), 0);
    document.getElementById('headerStat').innerHTML =
      dirtyCount > 0
        ? `<em>${dirtyCount}</em> unsaved`
        : `<em>${totalTagged}</em> total tags`;

    updateProgress();
    refreshSelectLabels();
    selHint.classList.remove('visible');
  }

  function updateProgress() {
    const total = evidence.length;
    const reviewed = Object.keys(reviewedDocs).length;
    document.getElementById('progressText').textContent = `${reviewed} / ${total}`;
    document.getElementById('progressFill').style.width = `${total > 0 ? (reviewed / total) * 100 : 0}%`;
  }

  // ========================================================================
  // KEYBOARD SHORTCUTS
  // ========================================================================
  document.addEventListener('keydown', (e) => {
    // Don't capture if user is in an input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      document.getElementById('prevDoc').click();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      document.getElementById('nextDoc').click();
    } else if (e.key === 'r') {
      const check = document.getElementById('reviewCheck');
      check.checked = !check.checked;
      check.dispatchEvent(new Event('change'));
    } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      document.getElementById('btnSave').click();
    }
  });

  // ========================================================================
  // WARN ON CLOSE WITH UNSAVED CHANGES
  // ========================================================================
  window.addEventListener('beforeunload', (e) => {
    if (dirtyCount > 0) {
      e.preventDefault();
      e.returnValue = '';
    }
  });

  // ========================================================================
  // INIT
  // ========================================================================
  buildSidebar();
  updateProgress();

  document.getElementById('loading').style.display = 'none';
  document.getElementById('header').style.display = 'flex';
  document.getElementById('mainLayout').style.display = 'grid';

})();
</script>
</body>
</html>
