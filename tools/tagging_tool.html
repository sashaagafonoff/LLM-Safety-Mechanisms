<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Safety Mechanism Tagging Tool</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;1,400&family=Overpass+Mono:wght@400;600&family=Source+Sans+3:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap');

  :root {
    --bg: #111318;
    --surface: #191c24;
    --surface-2: #21252f;
    --surface-3: #2a2f3b;
    --border: #2e3445;
    --border-light: #3a4055;
    --text: #d8dbe6;
    --text-dim: #7d829a;
    --text-faint: #555a6e;
    --accent: #5eadf2;
    --accent-dim: rgba(94, 173, 242, 0.15);
    --tagged: #3dd9a0;
    --tagged-dim: rgba(61, 217, 160, 0.12);
    --tagged-border: rgba(61, 217, 160, 0.4);
    --evidence-bg: rgba(61, 217, 160, 0.08);
    --warning: #f0c45a;
    --danger: #e06356;
    --selection-bg: rgba(94, 173, 242, 0.25);
    --selection-border: rgba(94, 173, 242, 0.5);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Source Sans 3', sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* ==================== HEADER ==================== */
  .header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 0 20px;
    height: 50px;
    display: flex;
    align-items: center;
    gap: 14px;
    flex-shrink: 0;
    z-index: 100;
  }

  .logo {
    font-family: 'Overpass Mono', monospace;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 0.08em;
    color: var(--text-dim);
    white-space: nowrap;
    border-right: 1px solid var(--border);
    padding-right: 14px;
  }

  .logo em {
    color: var(--tagged);
    font-style: normal;
  }

  .doc-select-wrap {
    flex: 1;
    max-width: 560px;
    position: relative;
  }

  .doc-select {
    width: 100%;
    padding: 6px 30px 6px 10px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font-family: inherit;
    font-size: 12.5px;
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='%237d829a'%3E%3Cpath d='M5 7L0 2h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
  }

  .doc-select:focus { outline: none; border-color: var(--accent); }
  .doc-select option { background: var(--surface-2); }
  .doc-select optgroup { color: var(--text-dim); font-weight: 600; }

  .nav-group {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .btn {
    height: 30px;
    padding: 0 12px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--surface-2);
    color: var(--text-dim);
    font-family: inherit;
    font-size: 11.5px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.12s;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    gap: 5px;
  }

  .btn:hover { background: var(--surface-3); color: var(--text); border-color: var(--border-light); }
  .btn-nav { padding: 0 7px; font-size: 13px; }
  .btn-save { border-color: var(--tagged-border); color: var(--tagged); }
  .btn-save:hover { background: var(--tagged-dim); }

  .review-label {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-dim);
    cursor: pointer;
    user-select: none;
  }

  .review-label input { accent-color: var(--tagged); width: 14px; height: 14px; cursor: pointer; }

  .header-spacer { flex: 1; }

  .header-stat {
    font-family: 'Overpass Mono', monospace;
    font-size: 11px;
    color: var(--text-dim);
  }

  .header-stat em { font-style: normal; color: var(--tagged); }

  /* ==================== MAIN LAYOUT ==================== */
  .main {
    display: grid;
    grid-template-columns: 1fr 340px;
    flex: 1;
    overflow: hidden;
  }

  /* ==================== DOCUMENT VIEWER ==================== */
  .doc-panel {
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .doc-toolbar {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 8px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    flex-shrink: 0;
    min-height: 38px;
  }

  .doc-toolbar .doc-title-bar {
    font-weight: 500;
    font-size: 13px;
    color: var(--text);
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .doc-toolbar .doc-type-badge {
    font-family: 'Overpass Mono', monospace;
    font-size: 10px;
    padding: 2px 7px;
    background: var(--surface-3);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-dim);
    flex-shrink: 0;
  }

  .doc-toolbar .doc-provider-badge {
    font-size: 11px;
    color: var(--text-dim);
    flex-shrink: 0;
  }

  .doc-toolbar a {
    color: var(--accent);
    font-size: 11px;
    text-decoration: none;
    flex-shrink: 0;
  }

  .doc-toolbar a:hover { text-decoration: underline; }

  .model-chips {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    flex-shrink: 0;
  }

  .model-chip {
    font-family: 'Overpass Mono', monospace;
    font-size: 9.5px;
    padding: 1px 6px;
    background: var(--surface-3);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-dim);
  }

  .doc-content {
    flex: 1;
    overflow-y: auto;
    padding: 28px 40px 80px 40px;
    line-height: 1.75;
    font-family: 'Crimson Pro', serif;
    font-size: 17px;
    color: var(--text);
    cursor: text;
  }

  .doc-content::selection { background: var(--selection-bg); }
  .doc-content *::selection { background: var(--selection-bg); }

  .doc-content::-webkit-scrollbar { width: 7px; }
  .doc-content::-webkit-scrollbar-track { background: transparent; }
  .doc-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

  .doc-empty {
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    color: var(--text-faint);
    font-size: 14px;
    text-align: center;
    padding: 40px;
  }

  .doc-empty .empty-icon { font-size: 32px; margin-bottom: 10px; opacity: 0.4; }
  .doc-empty p { max-width: 340px; line-height: 1.6; }

  /* Evidence highlighting */
  .evidence-highlight {
    background: var(--evidence-bg);
    border-bottom: 2px solid var(--tagged);
    padding: 1px 0;
    cursor: pointer;
    transition: background 0.15s;
    border-radius: 2px;
  }

  .evidence-highlight:hover {
    background: rgba(61, 217, 160, 0.18);
  }

  .evidence-highlight .ev-tag {
    display: inline;
    font-family: 'Overpass Mono', monospace;
    font-size: 9px;
    background: var(--tagged);
    color: var(--bg);
    padding: 1px 4px;
    border-radius: 2px;
    margin-left: 3px;
    vertical-align: super;
    cursor: pointer;
    font-weight: 600;
  }

  /* Selection hint */
  .selection-hint {
    position: fixed;
    background: var(--surface-2);
    border: 1px solid var(--selection-border);
    border-radius: 5px;
    padding: 5px 10px;
    font-size: 11px;
    color: var(--accent);
    pointer-events: none;
    z-index: 200;
    opacity: 0;
    transition: opacity 0.15s;
    font-family: 'Source Sans 3', sans-serif;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }

  .selection-hint.visible { opacity: 1; }

  /* ==================== SIDEBAR ==================== */
  .sidebar {
    background: var(--surface);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .sidebar-header {
    padding: 12px 14px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .sidebar-header h2 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-dim);
  }

  .tag-counter {
    font-family: 'Overpass Mono', monospace;
    font-size: 12px;
    color: var(--tagged);
  }

  .tag-counter span { color: var(--text-faint); }

  .sidebar-scroll {
    flex: 1;
    overflow-y: auto;
    padding: 8px 0;
  }

  .sidebar-scroll::-webkit-scrollbar { width: 5px; }
  .sidebar-scroll::-webkit-scrollbar-track { background: transparent; }
  .sidebar-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .cat-group { margin-bottom: 6px; }

  .cat-header {
    padding: 6px 14px 4px;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-faint);
    display: flex;
    align-items: center;
    gap: 6px;
    position: sticky;
    top: 0;
    background: var(--surface);
    z-index: 2;
  }

  .cat-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .tech-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 5px 14px 5px 14px;
    cursor: pointer;
    transition: background 0.1s;
    user-select: none;
    position: relative;
  }

  .tech-item:hover { background: var(--surface-2); }

  .tech-item.tagged {
    background: var(--tagged-dim);
  }

  .tech-item.tagged:hover {
    background: rgba(61, 217, 160, 0.18);
  }

  .tech-check {
    width: 15px;
    height: 15px;
    border: 1.5px solid var(--border-light);
    border-radius: 3px;
    flex-shrink: 0;
    margin-top: 1px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.12s;
    font-size: 9px;
    color: transparent;
  }

  .tech-item.tagged .tech-check {
    background: var(--tagged);
    border-color: var(--tagged);
    color: var(--bg);
  }

  .tech-body {
    flex: 1;
    min-width: 0;
  }

  .tech-name {
    font-size: 12px;
    line-height: 1.35;
    color: var(--text-dim);
    transition: color 0.1s;
  }

  .tech-item.tagged .tech-name { color: var(--text); }

  .tech-evidence-list {
    margin-top: 3px;
  }

  .ev-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
    padding: 1px 0;
    min-height: 16px;
  }

  .ev-link {
    font-size: 10px;
    color: var(--text-faint);
    line-height: 1.3;
    font-family: 'Overpass Mono', monospace;
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .ev-link.has-evidence { color: var(--tagged); opacity: 0.7; }
  .ev-link.ev-missing { color: var(--warning); opacity: 0.85; }
  .ev-link.ev-manual { color: var(--text-faint); }
  .ev-link.ev-deleted-link { color: var(--text-faint); opacity: 0.5; }
  .ev-link.ev-deleted-link s { text-decoration: line-through; }

  /* Provenance markers */
  .prov-marker {
    font-family: 'Overpass Mono', monospace;
    font-size: 9px;
    font-weight: 600;
    margin-right: 2px;
  }
  .prov-nlu { color: #7cacf8; }  /* Blue for NLU */
  .prov-llm { color: #c49cf8; }  /* Purple for LLM */
  .prov-manual { color: var(--tagged); }  /* Green for Manual */
  .prov-legacy { color: var(--text-faint); }  /* Gray for legacy/unknown */

  /* Deleted evidence row */
  .ev-row.ev-deleted {
    opacity: 0.5;
    background: rgba(224, 99, 86, 0.05);
  }

  .ev-link.clickable {
    cursor: pointer;
  }

  .ev-link.clickable:hover {
    opacity: 1;
    text-decoration: underline;
  }

  .ev-remove {
    font-size: 9px;
    color: var(--text-faint);
    cursor: pointer;
    padding: 0 3px;
    border-radius: 2px;
    flex-shrink: 0;
    line-height: 1.4;
    opacity: 0;
    transition: opacity 0.1s, color 0.1s, background 0.1s;
  }

  .ev-row:hover .ev-remove {
    opacity: 1;
  }

  .ev-remove:hover {
    color: var(--danger);
    background: rgba(224, 99, 86, 0.15);
  }

  .tech-item.tagged.ev-missing-item {
    background: rgba(240, 196, 90, 0.06);
  }

  /* Scroll-target pulse on evidence highlight */
  @keyframes ev-pulse {
    0% { box-shadow: 0 0 0 0 rgba(61, 217, 160, 0.5); }
    50% { box-shadow: 0 0 0 4px rgba(61, 217, 160, 0.3); }
    100% { box-shadow: 0 0 0 0 rgba(61, 217, 160, 0); }
  }

  .evidence-highlight.pulse {
    animation: ev-pulse 0.8s ease-out 2;
  }

  /* Sidebar item flash on scroll-to */
  @keyframes sidebar-flash {
    0% { outline: 2px solid var(--accent); outline-offset: -1px; }
    100% { outline: 2px solid transparent; outline-offset: -1px; }
  }

  .tech-item.flash-highlight {
    animation: sidebar-flash 1.5s ease-out forwards;
  }

  .tech-info-btn {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    color: var(--text-faint);
    flex-shrink: 0;
    margin-top: 1px;
    cursor: help;
    transition: all 0.12s;
    border: 1px solid transparent;
  }

  .tech-info-btn:hover {
    color: var(--accent);
    background: var(--accent-dim);
    border-color: rgba(94, 173, 242, 0.3);
  }

  /* ==================== TECHNIQUE TOOLTIP ==================== */
  .tech-tooltip {
    position: fixed;
    background: var(--surface-2);
    border: 1px solid var(--border-light);
    border-radius: 6px;
    padding: 12px 14px;
    font-size: 12px;
    z-index: 300;
    max-width: 360px;
    box-shadow: 0 8px 28px rgba(0,0,0,0.5);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.12s;
    line-height: 1.5;
  }

  .tech-tooltip.visible { opacity: 1; }

  .tech-tooltip .tt-title {
    font-weight: 600;
    font-size: 13px;
    margin-bottom: 6px;
    color: var(--text);
  }

  .tech-tooltip .tt-section {
    margin-bottom: 6px;
  }

  .tech-tooltip .tt-label {
    font-size: 9.5px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-faint);
    margin-bottom: 2px;
  }

  .tech-tooltip .tt-text {
    color: var(--text-dim);
    font-size: 11.5px;
  }

  .tech-tooltip .tt-anchors {
    display: flex;
    flex-wrap: wrap;
    gap: 3px;
    margin-top: 3px;
  }

  .tech-tooltip .tt-anchor-tag {
    font-family: 'Overpass Mono', monospace;
    font-size: 9.5px;
    padding: 1px 5px;
    background: var(--surface-3);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-dim);
  }

  /* ==================== SIDEBAR FOOTER ==================== */
  .sidebar-footer {
    padding: 10px 14px;
    border-top: 1px solid var(--border);
    background: var(--surface-2);
  }

  .progress-row {
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    color: var(--text-faint);
    margin-bottom: 5px;
  }

  .progress-bar {
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: var(--tagged);
    border-radius: 2px;
    transition: width 0.3s;
  }

  /* ==================== FLASH MESSAGE ==================== */
  .flash {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 7px 16px;
    border-radius: 5px;
    font-size: 12px;
    font-weight: 500;
    z-index: 300;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }

  .flash.visible { opacity: 1; }
  .flash.flash-tag { background: var(--tagged); color: var(--bg); }
  .flash.flash-untag { background: var(--surface-3); color: var(--text-dim); border: 1px solid var(--border); }
  .flash.flash-save { background: var(--accent); color: #fff; }
  .flash.flash-error { background: var(--danger); color: #fff; }

  /* ==================== LOADING ==================== */
  .loading-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--bg);
    z-index: 999;
    gap: 14px;
  }

  .spinner {
    width: 24px;
    height: 24px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.7s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-overlay p { color: var(--text-dim); font-size: 12px; }
</style>
</head>
<body>

<div class="loading-overlay" id="loading">
  <div class="spinner"></div>
  <p>Loading project data‚Ä¶</p>
</div>

<div class="tech-tooltip" id="techTooltip"></div>
<div class="selection-hint" id="selectionHint">Click a technique to attach this text as evidence ‚Üí</div>
<div class="flash" id="flash"></div>

<div class="header" id="header" style="display:none;">
  <div class="logo"><em>‚ñ™</em> TAG</div>

  <div class="nav-group">
    <button class="btn btn-nav" id="prevDoc" title="Previous (‚Üê)">‚óÄ</button>
    <button class="btn btn-nav" id="nextDoc" title="Next (‚Üí)">‚ñ∂</button>
  </div>

  <div class="doc-select-wrap">
    <select class="doc-select" id="docSelect">
      <option value="">Select a document‚Ä¶</option>
    </select>
  </div>

  <label class="review-label" id="reviewWrap" style="display:none;">
    <input type="checkbox" id="reviewCheck"> Reviewed
  </label>

  <div class="header-spacer"></div>

  <div class="header-stat" id="headerStat"></div>

  <button class="btn" id="btnClear" style="display:none;">Clear</button>
  <button class="btn btn-save" id="btnSave">Save</button>
</div>

<div class="main" id="mainLayout" style="display:none;">
  <!-- DOCUMENT PANEL -->
  <div class="doc-panel" id="docPanel">
    <div class="doc-toolbar" id="docToolbar" style="display:none;">
      <span class="doc-title-bar" id="docTitleBar"></span>
      <div class="model-chips" id="modelChips"></div>
      <span class="doc-type-badge" id="docTypeBadge"></span>
      <span class="doc-provider-badge" id="docProvBadge"></span>
      <a href="#" id="docLink" target="_blank" style="display:none;">Open ‚Üó</a>
    </div>
    <div class="doc-empty" id="docEmpty">
      <div>
        <div class="empty-icon">üìÑ</div>
        <p>Select a document from the dropdown to begin reviewing and tagging safety techniques.</p>
        <p style="margin-top:8px;font-size:12px;color:var(--text-faint)">
          Serve this file from the repo root:<br>
          <code style="font-family:'Overpass Mono',monospace;background:var(--surface-2);padding:2px 6px;border-radius:3px;">python -m http.server 8000</code><br>
          Then open <code style="font-family:'Overpass Mono',monospace;background:var(--surface-2);padding:2px 6px;border-radius:3px;">http://localhost:8000/tools/tagging_tool.html</code>
        </p>
      </div>
    </div>
    <div class="doc-content" id="docContent" style="display:none;"></div>
  </div>

  <!-- SIDEBAR -->
  <div class="sidebar">
    <div class="sidebar-header">
      <h2>Techniques</h2>
      <div class="tag-counter" id="tagCounter">0<span> / 0</span></div>
    </div>
    <div class="sidebar-scroll" id="sidebarList"></div>
    <div class="sidebar-footer">
      <div class="progress-row">
        <span>Documents reviewed</span>
        <span id="progressText">0 / 0</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width:0%"></div>
      </div>
    </div>
  </div>
</div>

<script>
(async function() {

  // ========================================================================
  // DATA LOADING ‚Äî uses relative paths from repo root
  // ========================================================================
  const BASE = '../data';

  let evidence, techniques, categories, techniqueMap, providers;

  try {
    [evidence, techniques, categories, techniqueMap, providers] = await Promise.all([
      fetch(`${BASE}/evidence.json`).then(r => { if (!r.ok) throw new Error('evidence.json'); return r.json(); }).then(d => d.sources || d),
      fetch(`${BASE}/techniques.json`).then(r => { if (!r.ok) throw new Error('techniques.json'); return r.json(); }),
      fetch(`${BASE}/categories.json`).then(r => { if (!r.ok) throw new Error('categories.json'); return r.json(); }),
      fetch(`${BASE}/model_technique_map.json`).then(r => { if (!r.ok) throw new Error('model_technique_map.json'); return r.json(); }),
      fetch(`${BASE}/providers.json`).then(r => { if (!r.ok) throw new Error('providers.json'); return r.json(); })
    ]);
  } catch(e) {
    document.getElementById('loading').innerHTML =
      `<p style="color:var(--danger);">Failed to load <strong>${e.message}</strong>.<br>
       Make sure you're serving from the repo root:<br>
       <code style="font-family:monospace">python -m http.server 8000</code></p>`;
    return;
  }

  // ========================================================================
  // NORMALIZE MAP KEYS ‚Üí evidence IDs
  // ========================================================================
  // The NLU pipeline writes map keys as URLs or titles, but we need evidence
  // IDs as canonical keys. Build reverse lookups and re-key the map.

  console.group('[TAG] Data load summary');
  console.log('Evidence sources:', evidence.length, evidence.map(d => d.id));
  console.log('Techniques:', techniques.length);
  console.log('Raw map keys:', Object.keys(techniqueMap));
  console.log('Raw map key count:', Object.keys(techniqueMap).length);
  // Show non-empty entries
  const nonEmpty = Object.entries(techniqueMap).filter(([k,v]) => v && v.length > 0);
  console.log('Non-empty map entries:', nonEmpty.length, nonEmpty.map(([k,v]) => `${k} (${v.length} techs)`));
  console.groupEnd();

  const urlToEvidenceId = new Map();
  const titleToEvidenceId = new Map();
  const evidenceIdSet = new Set();
  evidence.forEach(doc => {
    evidenceIdSet.add(doc.id);
    if (doc.url) urlToEvidenceId.set(doc.url, doc.id);
    if (doc.title) titleToEvidenceId.set(doc.title, doc.id);
  });

  console.group('[TAG] URL ‚Üí ID lookup table');
  urlToEvidenceId.forEach((id, url) => console.log(`  ${url} ‚Üí ${id}`));
  console.groupEnd();

  function resolveMapKey(key) {
    // Already an evidence ID?
    if (evidenceIdSet.has(key)) return key;
    // URL match?
    if (urlToEvidenceId.has(key)) return urlToEvidenceId.get(key);
    // Title match?
    if (titleToEvidenceId.has(key)) return titleToEvidenceId.get(key);
    // Unknown key ‚Äî keep as-is (orphan)
    return key;
  }

  // Re-key the technique map
  const normalizedMap = {};
  const orphanKeys = [];
  console.group('[TAG] Key resolution');
  for (const [key, value] of Object.entries(techniqueMap)) {
    const resolved = resolveMapKey(key);
    const status = resolved === key ? 'ID-match' : evidenceIdSet.has(resolved) ? `RESOLVED ‚Üí ${resolved}` : 'ORPHAN';
    if (value && value.length > 0) {
      console.log(`  ${key} [${value.length} techs] ‚Üí ${status}`);
    }
    if (!evidenceIdSet.has(resolved)) {
      orphanKeys.push(key);
    }
    // Merge if key already exists (e.g. both ID and URL entries for same doc)
    if (normalizedMap[resolved]) {
      const existing = new Set(normalizedMap[resolved].map(t => t.techniqueId));
      value.forEach(entry => {
        if (!existing.has(entry.techniqueId)) {
          normalizedMap[resolved].push(entry);
        }
      });
    } else {
      normalizedMap[resolved] = value;
    }
  }
  console.groupEnd();

  if (orphanKeys.length > 0) {
    console.warn('[TAG] ‚ö† Orphan keys (not in evidence.json):', orphanKeys);
  }

  console.group('[TAG] Normalized map summary');
  const normalizedNonEmpty = Object.entries(normalizedMap).filter(([k,v]) => v && v.length > 0);
  console.log('Total keys:', Object.keys(normalizedMap).length, '| Non-empty:', normalizedNonEmpty.length);
  normalizedNonEmpty.forEach(([k,v]) => console.log(`  ${k}: ${v.map(t => t.techniqueId).join(', ')}`));
  console.groupEnd();

  // ========================================================================
  // STATE
  // ========================================================================
  const tagState = JSON.parse(JSON.stringify(normalizedMap));
  const reviewedDocs = JSON.parse(localStorage.getItem('tagging-reviewed') || '{}');
  let currentDocId = null;
  let currentDocText = null;      // raw flat text for current doc
  let pendingSelection = null;    // { text } captured from document selection

  // Flag for save state
  let dirtyCount = 0;  // unsaved changes

  // Evidence match tracking per technique per snippet:
  // techId ‚Üí { overall: 'matched'|'unmatched'|'manual', snippets: [{index, state, text}] }
  const evidenceMatchState = new Map();

  // File handle for File System Access API
  let fileHandle = null;

  // ========================================================================
  // LOOKUPS
  // ========================================================================
  const catLookup = new Map(categories.map(c => [c.id, c]));
  const techLookup = new Map(techniques.map(t => [t.id, t]));
  const providerLookup = new Map(providers.map(p => [p.id, p]));

  const categoryNames = categories.map(c => c.name).sort();
  const categoryColors = {};
  const hueStep = 360 / categoryNames.length;
  categoryNames.forEach((name, i) => {
    categoryColors[name] = d3hsl(i * hueStep, 0.55, 0.5);
  });

  // Minimal HSL helper (avoids needing d3 for this)
  function d3hsl(h, s, l) {
    return `hsl(${h}, ${Math.round(s*100)}%, ${Math.round(l*100)}%)`;
  }

  // Group techniques by category
  const techByCategory = new Map();
  techniques.forEach(t => {
    const catName = catLookup.get(t.categoryId)?.name || 'Other';
    if (!techByCategory.has(catName)) techByCategory.set(catName, []);
    techByCategory.get(catName).push(t);
  });

  // ========================================================================
  // HELPERS
  // ========================================================================
  function getDocTags() {
    if (!currentDocId) return [];
    const tags = tagState[currentDocId] || [];
    console.log(`[TAG] getDocTags("${currentDocId}"): ${tags.length} tags`, tags.length > 0 ? tags.map(t => t.techniqueId) : '(empty)');
    return tags;
  }

  function isTagged(techId) {
    return getDocTags().some(t => t.techniqueId === techId);
  }

  function getTagEntry(techId) {
    return getDocTags().find(t => t.techniqueId === techId);
  }

  function flash(msg, type) {
    const el = document.getElementById('flash');
    el.textContent = msg;
    el.className = `flash visible flash-${type}`;
    clearTimeout(el._t);
    el._t = setTimeout(() => el.classList.remove('visible'), 1500);
  }

  // Normalize text for fuzzy matching: collapse whitespace, lowercase, fix ligatures
  function normalize(text) {
    return text
      .replace(/\ufb01/g, 'fi')    // fi ligature
      .replace(/\ufb02/g, 'fl')    // fl ligature
      .replace(/\ufb00/g, 'ff')    // ff ligature
      .replace(/\ufb03/g, 'ffi')   // ffi ligature
      .replace(/\ufb04/g, 'ffl')   // ffl ligature
      .replace(/[\u2018\u2019\u201A]/g, "'")   // smart quotes
      .replace(/[\u201C\u201D\u201E]/g, '"')
      .replace(/[\u2013\u2014]/g, '-')         // en/em dash
      .replace(/\u2026/g, '...')               // ellipsis
      .replace(/\f/g, ' ')                     // form feed
      .replace(/\s+/g, ' ')
      .trim()
      .toLowerCase();
  }

  // Normalize text AND build a map from each normalized char index back to
  // its original char index.  This handles ligature expansion (1 orig ‚Üí 2-3
  // norm chars), ellipsis expansion, smart-quote replacement, and whitespace
  // collapsing ‚Äî all of which shift positions if not tracked precisely.
  function normalizeWithMap(text) {
    const map = [];          // map[normIdx] = origIdx
    let result = '';
    let inWhitespace = false;

    const ligatures = {
      '\ufb01': 'fi', '\ufb02': 'fl', '\ufb00': 'ff',
      '\ufb03': 'ffi', '\ufb04': 'ffl'
    };

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];

      // Ligatures: 1 original char ‚Üí 2-3 normalized chars
      if (ligatures[ch]) {
        inWhitespace = false;
        for (const c of ligatures[ch]) { map.push(i); result += c; }
        continue;
      }

      // Ellipsis: 1 ‚Üí 3
      if (ch === '\u2026') {
        inWhitespace = false;
        for (let j = 0; j < 3; j++) { map.push(i); result += '.'; }
        continue;
      }

      // 1:1 replacements
      let c = ch;
      if (/[\u2018\u2019\u201A]/.test(ch)) c = "'";
      else if (/[\u201C\u201D\u201E]/.test(ch)) c = '"';
      else if (/[\u2013\u2014]/.test(ch)) c = '-';
      else if (ch === '\f') c = ' ';

      // Whitespace collapsing
      if (/\s/.test(c)) {
        if (!inWhitespace) { map.push(i); result += ' '; inWhitespace = true; }
        continue;
      }

      inWhitespace = false;
      map.push(i);
      result += c.toLowerCase();
    }

    // Trim
    let start = 0;
    while (start < result.length && result[start] === ' ') start++;
    let end = result.length;
    while (end > start && result[end - 1] === ' ') end--;

    return { norm: result.slice(start, end), map: map.slice(start, end) };
  }

  // Convert a normalized-index range to an original-text range using the map
  function normRangeToOrig(map, normStart, normEnd, fullTextLength) {
    if (normStart >= map.length) return null;
    const origStart = map[normStart];
    const origEnd = normEnd < map.length ? map[normEnd] : fullTextLength;
    return origEnd > origStart ? { start: origStart, end: origEnd } : null;
  }

  // Find best match of a snippet within the full text.
  // Returns { start, end } indices in the original text, or null.
  function findEvidence(fullText, snippet) {
    if (!snippet || !fullText) return null;

    const { norm: normFull, map } = normalizeWithMap(fullText);
    const normSnip = normalize(snippet);

    // Helper: convert normalized range to original range
    function toOrig(nStart, nEnd) {
      return normRangeToOrig(map, nStart, nEnd, fullText.length);
    }

    // Try exact normalized match first
    let idx = normFull.indexOf(normSnip);
    if (idx !== -1) {
      return toOrig(idx, idx + normSnip.length);
    }

    // Extract significant keywords from snippet for verification
    const stopWords = new Set(['the','a','an','and','or','but','in','on','at','to','for','of','with','by','from','is','are','was','were','be','been','being','have','has','had','do','does','did','will','would','could','should','may','might','can','this','that','these','those','it','its','we','our','they','their','not','no','also','as','such','more','most','very','all','any','each','than','other','into','about','which','when','where','how','what','who','if','then','so']);
    const snippetKeywords = normSnip.split(/\s+/).filter(w => w.length > 3 && !stopWords.has(w));

    // Verify a candidate region has sufficient keyword overlap with the snippet
    function verifyRegion(candidateStart, candidateEnd) {
      const region = normFull.slice(candidateStart, candidateEnd);
      if (snippetKeywords.length === 0) return true;
      const hits = snippetKeywords.filter(kw => region.includes(kw)).length;
      return hits / snippetKeywords.length >= 0.35;
    }

    // Find the natural end boundary (sentence-ending punctuation or double newline)
    function findSentenceEnd(startIdx, maxLen) {
      const searchEnd = Math.min(startIdx + maxLen, normFull.length);
      const region = normFull.slice(startIdx, searchEnd);
      const targetLen = normSnip.length;
      for (let offset = 0; offset < 80 && targetLen + offset < region.length; offset++) {
        const pos = targetLen + offset;
        if (region[pos] === '.' && (pos + 1 >= region.length || region[pos + 1] === ' ')) return startIdx + pos + 1;
        if (region[pos] === '\n') return startIdx + pos;
      }
      return Math.min(startIdx + targetLen, normFull.length);
    }

    // Try prefix matching with verification: 80 chars, then 40 chars
    for (const prefixLen of [80, 40]) {
      if (normSnip.length <= prefixLen) continue;
      const prefix = normSnip.substring(0, prefixLen);

      // Check all occurrences of this prefix, not just the first
      let searchFrom = 0;
      let bestMatch = null;
      let bestScore = 0;

      while (searchFrom < normFull.length) {
        idx = normFull.indexOf(prefix, searchFrom);
        if (idx === -1) break;

        const endIdx = findSentenceEnd(idx, normSnip.length + 80);
        if (verifyRegion(idx, endIdx)) {
          const region = normFull.slice(idx, endIdx);
          const hits = snippetKeywords.filter(kw => region.includes(kw)).length;
          const score = snippetKeywords.length > 0 ? hits / snippetKeywords.length : 1;
          if (score > bestScore) {
            bestScore = score;
            bestMatch = { start: idx, end: endIdx };
          }
        }
        searchFrom = idx + 1;
      }

      if (bestMatch) {
        return toOrig(bestMatch.start, bestMatch.end);
      }
    }

    // Last resort: keyword density search ‚Äî slide a window and find the best match
    if (snippetKeywords.length >= 3) {
      const windowLen = normSnip.length;
      const step = Math.max(20, Math.floor(windowLen / 4));
      let bestStart = -1, bestEnd = -1, bestScore = 0;

      for (let i = 0; i <= normFull.length - Math.min(windowLen / 2, normFull.length); i += step) {
        const end = Math.min(i + windowLen + 40, normFull.length);
        const region = normFull.slice(i, end);
        const hits = snippetKeywords.filter(kw => region.includes(kw)).length;
        const score = hits / snippetKeywords.length;
        if (score > bestScore && score >= 0.5) {
          bestScore = score;
          bestStart = i;
          bestEnd = end;
        }
      }

      if (bestStart !== -1) {
        return toOrig(bestStart, bestEnd);
      }
    }

    return null;
  }

  // ========================================================================
  // TOGGLE / EVIDENCE LOGIC
  // ========================================================================
  function toggleTech(techId) {
    if (!currentDocId) return;
    if (!tagState[currentDocId]) tagState[currentDocId] = [];

    const techName = techLookup.get(techId)?.name || techId;
    const existing = tagState[currentDocId].findIndex(t => t.techniqueId === techId);

    if (existing >= 0 && pendingSelection) {
      // Already tagged + text selected ‚Üí append evidence snippet
      const entry = tagState[currentDocId][existing];
      // Remove "Manual annotation" placeholder if present
      entry.evidence = entry.evidence.filter(e => {
        if (typeof e === 'string') return e !== 'Manual annotation';
        return e.text !== 'Manual annotation';
      });
      // Add new evidence in structured format
      entry.evidence.push({
        text: pendingSelection.text,
        created_by: 'manual',
        active: true,
        deleted_by: null
      });
      flash(`+ Added evidence for ${techName}`, 'tag');
    } else if (existing >= 0) {
      // Already tagged + no selection ‚Üí untag entirely
      tagState[currentDocId].splice(existing, 1);
      flash(`‚àí ${techName}`, 'untag');
    } else {
      // Not tagged ‚Üí tag, with evidence if text is selected
      const evidenceEntry = pendingSelection
        ? { text: pendingSelection.text, created_by: 'manual', active: true, deleted_by: null }
        : { text: 'Manual annotation', created_by: 'manual', active: true, deleted_by: null };
      tagState[currentDocId].push({
        techniqueId: techId,
        confidence: 'High',
        active: true,
        deleted_by: null,
        evidence: [evidenceEntry]
      });
      flash(`‚úì ${techName}`, 'tag');
    }

    pendingSelection = null;
    dirtyCount++;
    updateVisuals();
  }

  function removeEvidence(techId, snippetIndex) {
    if (!currentDocId) return;
    const tags = tagState[currentDocId] || [];
    const entry = tags.find(t => t.techniqueId === techId);
    if (!entry) return;

    const techName = techLookup.get(techId)?.name || techId;

    // Count active evidence (ignore already-deleted ones)
    const activeEvidence = entry.evidence.filter(e => {
      if (typeof e === 'object' && e !== null) return e.active !== false;
      return true;
    });

    if (activeEvidence.length <= 1) {
      // Last active snippet ‚Äî mark entire technique as deleted (soft delete)
      entry.active = false;
      entry.deleted_by = 'manual';
      flash(`‚àí ${techName}`, 'untag');
    } else {
      // Soft delete just this snippet
      const evItem = entry.evidence[snippetIndex];
      if (typeof evItem === 'object' && evItem !== null) {
        evItem.active = false;
        evItem.deleted_by = 'manual';
      } else {
        // Old string format - convert to object and mark deleted
        entry.evidence[snippetIndex] = {
          text: evItem,
          created_by: 'legacy',
          active: false,
          deleted_by: 'manual'
        };
      }
      flash(`‚àí Removed passage from ${techName}`, 'untag');
    }

    dirtyCount++;
    updateVisuals();
  }

  // ========================================================================
  // BUILD SIDEBAR
  // ========================================================================
  function buildSidebar() {
    const container = document.getElementById('sidebarList');
    container.innerHTML = '';

    const sorted = Array.from(techByCategory.entries()).sort((a,b) => a[0].localeCompare(b[0]));

    sorted.forEach(([catName, techs]) => {
      const group = document.createElement('div');
      group.className = 'cat-group';

      const header = document.createElement('div');
      header.className = 'cat-header';
      header.innerHTML = `<span class="cat-dot" style="background:${categoryColors[catName]}"></span>${catName}`;
      group.appendChild(header);

      techs.sort((a,b) => a.name.localeCompare(b.name)).forEach(t => {
        const item = document.createElement('div');
        item.className = 'tech-item';
        item.dataset.techId = t.id;

        item.innerHTML = `
          <div class="tech-check">‚úì</div>
          <div class="tech-body">
            <div class="tech-name">${t.name}</div>
            <div class="tech-evidence-list" data-tech-ev="${t.id}"></div>
          </div>
          <div class="tech-info-btn" data-info="${t.id}" title="View technique details">‚ìò</div>
        `;

        // Click handler ‚Äî checkbox always toggles
        item.querySelector('.tech-check').addEventListener('click', (e) => {
          e.stopPropagation();
          toggleTech(t.id);
        });

        // Name click ‚Äî if tagged with evidence, scroll to first matched snippet; otherwise toggle
        item.querySelector('.tech-name').addEventListener('click', (e) => {
          e.stopPropagation();
          if (isTagged(t.id) && !pendingSelection) {
            const matchInfo = evidenceMatchState.get(t.id);
            if (matchInfo?.overall === 'matched') {
              // Scroll to first matched snippet
              const firstMatched = matchInfo.snippets.find(s => s.state === 'matched');
              if (firstMatched) scrollToEvidence(t.id, firstMatched.index);
            } else if (matchInfo?.overall === 'unmatched') {
              flash(`‚ö† Evidence text not found in document`, 'error');
            }
            // 'manual' ‚Äî do nothing on name click (use checkbox to untag)
          } else {
            toggleTech(t.id);
          }
        });

        // Info button
        item.querySelector('.tech-info-btn').addEventListener('mouseenter', (e) => showTechTooltip(e, t));
        item.querySelector('.tech-info-btn').addEventListener('mouseleave', hideTechTooltip);

        group.appendChild(item);
      });

      container.appendChild(group);
    });
  }

  // ========================================================================
  // TECHNIQUE TOOLTIP
  // ========================================================================
  function showTechTooltip(event, tech) {
    const tip = document.getElementById('techTooltip');
    const nlu = tech.nlu_profile || {};
    const cat = catLookup.get(tech.categoryId);

    let html = `<div class="tt-title">${tech.name}</div>`;

    if (cat) {
      html += `<div class="tt-section"><div class="tt-label">Category</div><div class="tt-text">${cat.name}</div></div>`;
    }

    if (tech.description) {
      html += `<div class="tt-section"><div class="tt-label">Description</div><div class="tt-text">${tech.description}</div></div>`;
    }

    if (nlu.primary_concept) {
      html += `<div class="tt-section"><div class="tt-label">Concept</div><div class="tt-text">${nlu.primary_concept}</div></div>`;
    }

    if (nlu.semantic_anchors && nlu.semantic_anchors.length) {
      html += `<div class="tt-section"><div class="tt-label">Semantic Anchors</div><div class="tt-anchors">`;
      nlu.semantic_anchors.forEach(a => {
        html += `<span class="tt-anchor-tag">${a}</span>`;
      });
      html += `</div></div>`;
    }

    if (nlu.entailment_hypothesis) {
      html += `<div class="tt-section"><div class="tt-label">Hypothesis</div><div class="tt-text" style="font-style:italic;">"${nlu.entailment_hypothesis}"</div></div>`;
    }

    tip.innerHTML = html;
    tip.style.visibility = 'hidden';
    tip.classList.add('visible');

    // Position: to the left of the info button
    const rect = event.target.getBoundingClientRect();
    const tipW = tip.offsetWidth;
    const tipH = tip.offsetHeight;
    let left = rect.left - tipW - 10;
    let top = rect.top - 10;

    // Fallback if no room on left
    if (left < 10) left = rect.right + 10;
    // Keep on screen vertically
    top = Math.max(10, Math.min(top, window.innerHeight - tipH - 10));
    tip.style.left = left + 'px';
    tip.style.top = top + 'px';
    tip.style.visibility = '';
  }

  function hideTechTooltip() {
    document.getElementById('techTooltip').classList.remove('visible');
  }

  // ========================================================================
  // DOCUMENT SELECT
  // ========================================================================
  const docSelect = document.getElementById('docSelect');

  // Group by provider
  const evidenceByProvider = new Map();
  evidence.forEach(doc => {
    const provName = providerLookup.get(doc.provider)?.name || doc.provider;
    if (!evidenceByProvider.has(provName)) evidenceByProvider.set(provName, []);
    evidenceByProvider.get(provName).push(doc);
  });

  Array.from(evidenceByProvider.entries())
    .sort((a,b) => a[0].localeCompare(b[0]))
    .forEach(([provName, docs]) => {
      const og = document.createElement('optgroup');
      og.label = provName;
      docs.sort((a,b) => a.title.localeCompare(b.title)).forEach(doc => {
        const opt = document.createElement('option');
        opt.value = doc.id;
        opt.textContent = formatOptionLabel(doc);
        og.appendChild(opt);
      });
      docSelect.appendChild(og);
    });

  function formatOptionLabel(doc) {
    const tagCount = (tagState[doc.id] || []).length;
    const rev = reviewedDocs[doc.id] ? ' ‚úì' : '';
    return `${doc.title}  [${tagCount}]${rev}`;
  }

  function refreshSelectLabels() {
    docSelect.querySelectorAll('option').forEach(opt => {
      if (!opt.value) return;
      const doc = evidence.find(d => d.id === opt.value);
      if (doc) opt.textContent = formatOptionLabel(doc);
    });
  }

  // ========================================================================
  // SELECT DOCUMENT
  // ========================================================================
  async function selectDocument(docId) {
    currentDocId = docId;
    currentDocText = null;
    pendingSelection = null;

    console.group(`[TAG] selectDocument("${docId}")`);
    console.log('tagState has key?', docId in tagState);
    console.log('tagState[docId]:', tagState[docId]);
    console.log('All tagState keys:', Object.keys(tagState));

    const doc = evidence.find(d => d.id === docId);

    if (!doc) {
      document.getElementById('docToolbar').style.display = 'none';
      document.getElementById('docContent').style.display = 'none';
      document.getElementById('docEmpty').style.display = 'flex';
      document.getElementById('reviewWrap').style.display = 'none';
      document.getElementById('btnClear').style.display = 'none';
      updateVisuals();
      return;
    }

    // Show toolbar
    const toolbar = document.getElementById('docToolbar');
    toolbar.style.display = 'flex';
    document.getElementById('btnClear').style.display = '';
    document.getElementById('reviewWrap').style.display = 'flex';
    document.getElementById('reviewCheck').checked = !!reviewedDocs[docId];

    document.getElementById('docTitleBar').textContent = doc.title;
    document.getElementById('docTypeBadge').textContent = doc.type || 'N/A';
    const provName = providerLookup.get(doc.provider)?.name || doc.provider;
    document.getElementById('docProvBadge').textContent = provName;

    const link = document.getElementById('docLink');
    if (doc.url) {
      link.href = doc.url;
      link.style.display = '';
    } else {
      link.style.display = 'none';
    }

    const chips = document.getElementById('modelChips');
    chips.innerHTML = (doc.models || []).map(m =>
      `<span class="model-chip">${m.name || m.modelId}</span>`
    ).join('');

    // Load flat text
    const content = document.getElementById('docContent');
    const empty = document.getElementById('docEmpty');

    try {
      const resp = await fetch(`${BASE}/flat_text/${docId}.txt`);
      if (!resp.ok) throw new Error('not found');
      currentDocText = await resp.text();
      content.style.display = '';
      empty.style.display = 'none';
      renderDocument();
    } catch(e) {
      currentDocText = null;
      content.style.display = 'none';
      empty.style.display = 'flex';
      empty.innerHTML = `<div>
        <div class="empty-icon">‚ö†Ô∏è</div>
        <p>No flat text file found for this document.<br>
        <span style="font-size:12px;color:var(--text-faint);">
          Expected: <code style="font-family:'Overpass Mono',monospace;background:var(--surface-2);padding:2px 6px;border-radius:3px;">data/flat_text/${docId}.txt</code><br>
          Run <code style="font-family:'Overpass Mono',monospace;background:var(--surface-2);padding:2px 6px;border-radius:3px;">ingest_universal.py</code> to generate it.
        </span></p>
      </div>`;
    }

    console.groupEnd(); // selectDocument
    updateVisuals();
  }

  docSelect.addEventListener('change', () => selectDocument(docSelect.value));

  // ========================================================================
  // RENDER DOCUMENT WITH EVIDENCE HIGHLIGHTING
  // ========================================================================
  function renderDocument() {
    const content = document.getElementById('docContent');

    // Always reset and populate match state, even if no text
    evidenceMatchState.clear();
    const tags = getDocTags();

    console.group(`[TAG] renderDocument: ${tags.length} tags, hasText=${!!currentDocText} (${currentDocText ? currentDocText.length + ' chars' : 'none'})`);

    if (!currentDocText) {
      content.innerHTML = '';
      tags.forEach(tag => {
        // Normalize evidence to array and handle new structured format
        let rawEvidence = tag.evidence || [];
        const snippets = Array.isArray(rawEvidence) ? rawEvidence : [rawEvidence];
        const snippetDetails = [];
        snippets.forEach((s, i) => {
          // Handle both old string format and new object format
          const isObject = typeof s === 'object' && s !== null;
          const text = isObject ? (s.text || '') : s;
          const createdBy = isObject ? (s.created_by || 'legacy') : (text === 'Manual annotation' ? 'manual' : 'legacy');
          const isActive = isObject ? (s.active !== false) : true;
          const deletedBy = isObject ? s.deleted_by : null;

          snippetDetails.push({
            index: i,
            state: text === 'Manual annotation' ? 'manual' : 'unmatched',
            text: text,
            createdBy: createdBy,
            active: isActive,
            deletedBy: deletedBy
          });
        });
        const hasReal = snippetDetails.some(s => s.state !== 'manual' && s.active);
        evidenceMatchState.set(tag.techniqueId, {
          overall: hasReal ? 'unmatched' : (snippetDetails.length > 0 ? 'manual' : 'manual'),
          snippets: snippetDetails,
          techActive: tag.active !== false,
          techDeletedBy: tag.deleted_by || null
        });
      });
      console.log('No document text loaded');
      console.groupEnd();
      return;
    }

    // Collect all evidence ranges, tracking snippet index for unique IDs
    const ranges = [];
    tags.forEach(tag => {
      const tech = techLookup.get(tag.techniqueId);
      if (!tech) {
        console.warn(`  ‚úó techniqueId "${tag.techniqueId}" not found in techniques.json`);
        return;
      }

      // Normalize evidence to array and handle new structured format
      let rawEvidence = tag.evidence || [];
      const snippets = Array.isArray(rawEvidence) ? rawEvidence : [rawEvidence];
      const snippetDetails = [];

      snippets.forEach((snippet, sIdx) => {
        // Handle both old string format and new object format
        const isObject = typeof snippet === 'object' && snippet !== null;
        const text = isObject ? (snippet.text || '') : snippet;
        const createdBy = isObject ? (snippet.created_by || 'legacy') : (text === 'Manual annotation' ? 'manual' : 'legacy');
        const isActive = isObject ? (snippet.active !== false) : true;
        const deletedBy = isObject ? snippet.deleted_by : null;

        if (text === 'Manual annotation') {
          snippetDetails.push({ index: sIdx, state: 'manual', text: text, createdBy: 'manual', active: true, deletedBy: null });
          console.log(`  ‚óã ${tech.name}[${sIdx}]: manual`);
          return;
        }

        // Skip deleted evidence for matching purposes but still track it
        if (!isActive) {
          snippetDetails.push({ index: sIdx, state: 'deleted', text: text, createdBy: createdBy, active: false, deletedBy: deletedBy });
          console.log(`  ‚úó ${tech.name}[${sIdx}]: DELETED by ${deletedBy}`);
          return;
        }

        const match = findEvidence(currentDocText, text);
        if (match) {
          snippetDetails.push({ index: sIdx, state: 'matched', text: text, createdBy: createdBy, active: true, deletedBy: null });
          ranges.push({
            start: match.start,
            end: match.end,
            techId: tag.techniqueId,
            techName: tech.name,
            snippetIndex: sIdx,
            catName: catLookup.get(tech.categoryId)?.name || ''
          });
          console.log(`  ‚óè ${tech.name}[${sIdx}]: MATCHED at ${match.start}-${match.end} (${createdBy})`);
        } else {
          snippetDetails.push({ index: sIdx, state: 'unmatched', text: text, createdBy: createdBy, active: true, deletedBy: null });
          console.log(`  ‚ö† ${tech.name}[${sIdx}]: NOT FOUND ‚Äî "${text.substring(0, 60)}‚Ä¶" (${createdBy})`);
        }
      });

      const anyMatched = snippetDetails.some(s => s.state === 'matched' && s.active);
      const anyReal = snippetDetails.some(s => s.state !== 'manual' && s.active);
      evidenceMatchState.set(tag.techniqueId, {
        overall: anyMatched ? 'matched' : (anyReal ? 'unmatched' : 'manual'),
        snippets: snippetDetails,
        techActive: tag.active !== false,
        techDeletedBy: tag.deleted_by || null
      });
    });

    console.log('Evidence match summary:', Object.fromEntries(
      [...evidenceMatchState].map(([k, v]) => [k, v.overall + ` (${v.snippets.length} snippets)`])
    ));
    console.groupEnd();

    // Sort ranges by start position
    ranges.sort((a, b) => a.start - b.start);

    // Build HTML with highlights
    let html = '';
    let cursor = 0;

    // Merge overlapping ranges ‚Äî keep all snippet references
    const merged = [];
    ranges.forEach(r => {
      if (merged.length > 0) {
        const last = merged[merged.length - 1];
        if (r.start < last.end) {
          last.end = Math.max(last.end, r.end);
          last.refs.push({ techId: r.techId, techName: r.techName, snippetIndex: r.snippetIndex });
          return;
        }
      }
      merged.push({
        start: r.start,
        end: r.end,
        refs: [{ techId: r.techId, techName: r.techName, snippetIndex: r.snippetIndex }]
      });
    });

    merged.forEach(r => {
      if (r.start > cursor) {
        html += escapeAndFormat(currentDocText.slice(cursor, r.start));
      }

      // Build label tags and collect IDs
      const labelHtml = r.refs.map(ref =>
        `<span class="ev-tag" data-tech-id="${ref.techId}" data-snippet-idx="${ref.snippetIndex}">${ref.techName}</span>`
      ).join('');

      // Use first ref for primary ID, add data attrs for all
      const primaryId = `ev-${r.refs[0].techId}-${r.refs[0].snippetIndex}`;
      const allIds = r.refs.map(ref => `ev-${ref.techId}-${ref.snippetIndex}`).join(' ');

      html += `<span class="evidence-highlight" id="${primaryId}" data-ev-ids="${allIds}" data-tech-ids="${r.refs.map(ref => ref.techId).join(',')}">`
           +  escapeHtml(currentDocText.slice(r.start, r.end))
           +  labelHtml
           +  `</span>`;

      cursor = r.end;
    });

    if (cursor < currentDocText.length) {
      html += escapeAndFormat(currentDocText.slice(cursor));
    }

    content.innerHTML = html;

    // Also set IDs on merged highlights for non-primary refs (so each snippet has a scroll target)
    merged.forEach(r => {
      if (r.refs.length > 1) {
        const el = document.getElementById(`ev-${r.refs[0].techId}-${r.refs[0].snippetIndex}`);
        // Additional refs that share this highlight can find it via data-ev-ids
        // We don't create duplicate elements, scrollToEvidence will search by data attr
      }
    });

    // Click on evidence tags in document ‚Üí flash sidebar item
    content.querySelectorAll('.ev-tag').forEach(tag => {
      tag.addEventListener('click', (e) => {
        e.stopPropagation();
        scrollToSidebarItem(tag.dataset.techId);
      });
    });
  }

  function escapeHtml(text) {
    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function escapeAndFormat(text) {
    let html = escapeHtml(text);
    html = html.replace(/\n{2,}/g, '</p><p style="margin-top:12px;">');
    html = html.replace(/\n/g, '<br>');
    return html;
  }

  // ========================================================================
  // SCROLL NAVIGATION
  // ========================================================================
  function scrollToEvidence(techId, snippetIndex) {
    // Try exact ID first
    let el = document.getElementById(`ev-${techId}-${snippetIndex}`);

    // If not found as primary ID, search data-ev-ids attribute
    if (!el) {
      const target = `ev-${techId}-${snippetIndex}`;
      el = document.querySelector(`[data-ev-ids*="${target}"]`);
    }

    if (el) {
      el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      el.classList.remove('pulse');
      void el.offsetWidth;
      el.classList.add('pulse');

      // Select the evidence text
      try {
        const sel = window.getSelection();
        sel.removeAllRanges();
        const range = document.createRange();
        const textNodes = [];
        el.childNodes.forEach(node => {
          if (node.nodeType === Node.TEXT_NODE) textNodes.push(node);
        });
        if (textNodes.length > 0) {
          range.setStart(textNodes[0], 0);
          range.setEnd(textNodes[textNodes.length - 1], textNodes[textNodes.length - 1].length);
          sel.addRange(range);
        }
      } catch(e) { /* not critical */ }
    } else {
      flash(`‚ö† Evidence text not found in document`, 'error');
    }
  }

  function scrollToSidebarItem(techId) {
    const item = document.querySelector(`.tech-item[data-tech-id="${techId}"]`);
    if (item) {
      item.scrollIntoView({ behavior: 'smooth', block: 'center' });
      item.classList.remove('flash-highlight');
      void item.offsetWidth;
      item.classList.add('flash-highlight');
    }
  }

  // ========================================================================
  // TEXT SELECTION ‚Üí EVIDENCE CAPTURE
  // ========================================================================
  const selHint = document.getElementById('selectionHint');

  document.getElementById('docContent').addEventListener('mouseup', (e) => {
    const sel = window.getSelection();
    const text = sel.toString().trim();

    if (text.length > 10) {
      pendingSelection = { text };
      selHint.style.left = (e.clientX + 12) + 'px';
      selHint.style.top = (e.clientY - 30) + 'px';
      selHint.classList.add('visible');
    } else {
      pendingSelection = null;
      selHint.classList.remove('visible');
    }
  });

  // Hide hint when clicking outside doc or when selection clears
  document.addEventListener('mousedown', (e) => {
    if (!e.target.closest('.doc-content') && !e.target.closest('.tech-item') && !e.target.closest('.ev-row')) {
      pendingSelection = null;
      selHint.classList.remove('visible');
    }
  });

  // ========================================================================
  // NAV BUTTONS
  // ========================================================================
  function getDocIds() {
    return Array.from(docSelect.querySelectorAll('option'))
      .filter(o => o.value).map(o => o.value);
  }

  document.getElementById('prevDoc').addEventListener('click', () => {
    const ids = getDocIds();
    if (!ids.length) return;
    const idx = ids.indexOf(currentDocId);
    const nIdx = idx <= 0 ? ids.length - 1 : idx - 1;
    docSelect.value = ids[nIdx];
    selectDocument(ids[nIdx]);
  });

  document.getElementById('nextDoc').addEventListener('click', () => {
    const ids = getDocIds();
    if (!ids.length) return;
    const idx = ids.indexOf(currentDocId);
    const nIdx = idx >= ids.length - 1 ? 0 : idx + 1;
    docSelect.value = ids[nIdx];
    selectDocument(ids[nIdx]);
  });

  // ========================================================================
  // REVIEW TOGGLE
  // ========================================================================
  document.getElementById('reviewCheck').addEventListener('change', (e) => {
    if (!currentDocId) return;
    if (e.target.checked) reviewedDocs[currentDocId] = true;
    else delete reviewedDocs[currentDocId];
    localStorage.setItem('tagging-reviewed', JSON.stringify(reviewedDocs));
    updateProgress();
    refreshSelectLabels();
  });

  // ========================================================================
  // CLEAR TAGS
  // ========================================================================
  document.getElementById('btnClear').addEventListener('click', () => {
    if (!currentDocId) return;
    if (!confirm('Clear all tags for this document?')) return;
    tagState[currentDocId] = [];
    dirtyCount++;
    updateVisuals();
    refreshSelectLabels();
  });

  // ========================================================================
  // SAVE ‚Äî File System Access API with download fallback
  // ========================================================================
  document.getElementById('btnSave').addEventListener('click', async () => {
    const output = buildOutput();
    const json = JSON.stringify(output, null, 2);

    // Try File System Access API (Chrome/Edge)
    if ('showSaveFilePicker' in window) {
      try {
        if (!fileHandle) {
          fileHandle = await window.showSaveFilePicker({
            suggestedName: 'model_technique_map.json',
            types: [{
              description: 'JSON files',
              accept: { 'application/json': ['.json'] }
            }]
          });
        }
        const writable = await fileHandle.createWritable();
        await writable.write(json);
        await writable.close();
        dirtyCount = 0;
        flash('Saved to file', 'save');
        return;
      } catch(e) {
        if (e.name === 'AbortError') return; // user cancelled
        // Fall through to download
      }
    }

    // Fallback: download
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'model_technique_map.json';
    a.click();
    URL.revokeObjectURL(url);
    dirtyCount = 0;
    flash('Downloaded model_technique_map.json', 'save');
  });

  function buildOutput() {
    const output = {};
    // Preserve all existing keys from the normalized map
    for (const key of Object.keys(normalizedMap)) {
      output[key] = tagState[key] !== undefined ? tagState[key] : normalizedMap[key];
    }
    // Include new keys added during this session
    for (const key of Object.keys(tagState)) {
      if (!(key in output)) output[key] = tagState[key];
    }
    return output;
  }

  // ========================================================================
  // UPDATE VISUALS
  // ========================================================================
  function updateVisuals() {
    const tags = getDocTags();
    // Only count techniques that are active (not soft-deleted)
    const activeTags = tags.filter(t => t.active !== false);
    const taggedIds = new Set(activeTags.map(t => t.techniqueId));
    // Also track deleted techniques for display purposes
    const deletedTags = tags.filter(t => t.active === false);
    const deletedIds = new Set(deletedTags.map(t => t.techniqueId));

    // Render document FIRST to populate evidenceMatchState
    renderDocument();

    // Sidebar items (now evidenceMatchState is current)
    document.querySelectorAll('.tech-item').forEach(item => {
      const techId = item.dataset.techId;
      const tagged = taggedIds.has(techId);
      item.classList.toggle('tagged', tagged);

      const matchInfo = evidenceMatchState.get(techId);
      const overall = matchInfo?.overall || null;
      item.classList.toggle('ev-missing-item', tagged && overall === 'unmatched');

      // Evidence list
      const listEl = item.querySelector('.tech-evidence-list');
      listEl.innerHTML = '';

      if (tagged && currentDocId && matchInfo && matchInfo.snippets.length > 0) {
        listEl.style.display = '';

        matchInfo.snippets.forEach((snip) => {
          const row = document.createElement('div');
          row.className = 'ev-row';

          // Handle deleted evidence
          if (snip.state === 'deleted' || !snip.active) {
            row.classList.add('ev-deleted');
          }

          const link = document.createElement('span');
          link.className = 'ev-link';

          // Provenance marker: (N)=NLU, (L)=LLM, (M)=Manual
          const provenanceMap = { 'nlu': 'N', 'llm': 'L', 'manual': 'M', 'legacy': '?' };
          const provenance = provenanceMap[snip.createdBy] || '?';

          const preview = snip.text === 'Manual annotation'
            ? snip.text
            : snip.text.substring(0, 45) + (snip.text.length > 45 ? '‚Ä¶' : '');

          if (snip.state === 'deleted' || !snip.active) {
            // Show deleted with strikethrough style
            link.innerHTML = `<span class="prov-marker prov-${snip.createdBy}">(${provenance})</span> <s>${preview}</s>`;
            link.classList.add('ev-deleted-link');
            link.title = `Deleted by: ${snip.deletedBy || 'unknown'}`;
          } else if (snip.state === 'matched') {
            link.innerHTML = `<span class="prov-marker prov-${snip.createdBy}">(${provenance})</span> ‚óè ${preview}`;
            link.classList.add('has-evidence', 'clickable');
            link.addEventListener('click', (e) => {
              e.stopPropagation();
              scrollToEvidence(techId, snip.index);
            });
          } else if (snip.state === 'unmatched') {
            link.innerHTML = `<span class="prov-marker prov-${snip.createdBy}">(${provenance})</span> ‚ö† ${preview}`;
            link.classList.add('ev-missing');
          } else {
            link.innerHTML = `<span class="prov-marker prov-manual">(M)</span> ‚óã ${preview}`;
            link.classList.add('ev-manual');
          }

          const remove = document.createElement('span');
          remove.className = 'ev-remove';
          remove.textContent = '‚úï';
          remove.title = 'Remove this passage';
          remove.addEventListener('click', (e) => {
            e.stopPropagation();
            removeEvidence(techId, snip.index);
          });

          row.appendChild(link);
          row.appendChild(remove);
          listEl.appendChild(row);
        });
      } else {
        listEl.style.display = 'none';
      }
    });

    // Tag counter with match quality
    const matched = tags.filter(t => evidenceMatchState.get(t.techniqueId)?.overall === 'matched').length;
    const unmatched = tags.filter(t => evidenceMatchState.get(t.techniqueId)?.overall === 'unmatched').length;
    const manual = tags.filter(t => evidenceMatchState.get(t.techniqueId)?.overall === 'manual').length;

    let counterHtml = `${tags.length}<span> / ${techniques.length}</span>`;
    if (tags.length > 0 && currentDocId) {
      const parts = [];
      if (matched) parts.push(`<span style="color:var(--tagged)">${matched} found</span>`);
      if (unmatched) parts.push(`<span style="color:var(--warning)">${unmatched} missing</span>`);
      if (manual) parts.push(`<span style="color:var(--text-faint)">${manual} manual</span>`);
      counterHtml += `<br><span style="font-size:10px">${parts.join(' ¬∑ ')}</span>`;
    }
    document.getElementById('tagCounter').innerHTML = counterHtml;

    // Header stat
    const totalTagged = Object.values(tagState).reduce((sum, arr) => sum + (arr?.length || 0), 0);
    document.getElementById('headerStat').innerHTML =
      dirtyCount > 0
        ? `<em>${dirtyCount}</em> unsaved`
        : `<em>${totalTagged}</em> total tags`;

    updateProgress();
    refreshSelectLabels();
    selHint.classList.remove('visible');
  }

  function updateProgress() {
    const total = evidence.length;
    const reviewed = Object.keys(reviewedDocs).length;
    document.getElementById('progressText').textContent = `${reviewed} / ${total}`;
    document.getElementById('progressFill').style.width = `${total > 0 ? (reviewed / total) * 100 : 0}%`;
  }

  // ========================================================================
  // KEYBOARD SHORTCUTS
  // ========================================================================
  document.addEventListener('keydown', (e) => {
    // Don't capture if user is in an input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      document.getElementById('prevDoc').click();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      document.getElementById('nextDoc').click();
    } else if (e.key === 'r') {
      const check = document.getElementById('reviewCheck');
      check.checked = !check.checked;
      check.dispatchEvent(new Event('change'));
    } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      document.getElementById('btnSave').click();
    }
  });

  // ========================================================================
  // WARN ON CLOSE WITH UNSAVED CHANGES
  // ========================================================================
  window.addEventListener('beforeunload', (e) => {
    if (dirtyCount > 0) {
      e.preventDefault();
      e.returnValue = '';
    }
  });

  // ========================================================================
  // INIT
  // ========================================================================
  buildSidebar();
  updateProgress();

  document.getElementById('loading').style.display = 'none';
  document.getElementById('header').style.display = 'flex';
  document.getElementById('mainLayout').style.display = 'grid';

})();
</script>
</body>
</html>
