<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LLM Safety Mechanisms Explorer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <nav class="site-nav">
    <a href="./" class="active">Explorer</a>
    <a href="./tag.html">Tag &amp; Review</a>
  </nav>

  <main>
    <h1>LLM Safety Mechanisms Explorer</h1>
    <p>This project supports holistic analysis of Large Language Model safety mechanisms, using data from my <a href="https://github.com/sashaagafonoff/LLM-Safety-Mechanisms">LLM Safety Mechanisms GitHub repository</a>. Please raise any issues/suggestions via <a href="https://github.com/sashaagafonoff/LLM-Safety-Mechanisms/issues">GitHub</a>.</p>

    <h2>Why do we need it?</h2>
    <p>Understanding which safety mechanisms are implemented across large language models currently requires piecing together information from scattered documentation, each using different terminology and varying levels of detail. This work provides a structured, queryable view of safety technique coverage across major frontier models &mdash; as a coverage profile that assists researchers, practitioners, and policymakers to make informed risk assessments.</p>

    <hr>

    <h2>Provider-Technique Relationships</h2>
    <p>This is designed to support coverage analysis. Use the filter below this graph to reduce the dataset for improved clarity. You can apply force layout on selected subsets of nodes.</p>
    <div class="card" id="network-chart"><div class="loading">Loading&hellip;</div></div>

    <hr>

    <h2>Dataset Filter</h2>
    <p>Constrain the collection using the following tools.</p>
    <div id="filter-container"></div>

    <hr>

    <h2>Safety Mechanisms by Category</h2>
    <p>This chart provides a visual overview of the safety mechanisms documented in this project. The Categories and individual techniques have been defined as a common taxonomy across the set of providers over months of iteration and analysis. This has been a data-driven approach, collapsing members where there was high overlap. I've also removed life cycle stage as higher order categories, and these are now represented intersectionally with techniques in a different section of the dataset.</p>
    <div class="card" id="sunburst-chart"><div class="loading">Loading&hellip;</div></div>

    <hr>

    <h2>Summary Statistics</h2>
    <div id="summary-table"></div>

    <hr>

    <h2>Model Development Lifecycle</h2>
    <p>Safety techniques mapped across the six phases of model development. Techniques appearing in multiple phases are connected with bridge lines. The governance band spans the full lifecycle to reflect its cross-cutting nature. Use the provider filter to compare coverage profiles.</p>
    <div class="card" id="lifecycle-chart"><div class="loading">Loading&hellip;</div></div>

    <hr>

    <h2>Documentation Map</h2>
    <p>The following chart shows the relationship between documents in the collection to providers (via models). This is to provide a quick overview as to which documentation has been brought into the dataset for analysis and will also assist in coverage analysis as I identify gaps in information. Click and drag to move things around. You can export the layout and save it as you prefer. Tooltips on the document nodes provide the URIs for the original source document referenced.</p>
    <div class="card" id="doc-network"><div class="loading">Loading&hellip;</div></div>

    <div id="data-quality"></div>

    <hr>

    <h2>Export</h2>
    <div id="export-panel"></div>

    <hr>

    <h2>Current (&amp; Planned) Activity</h2>
    <p>This project is under active development. Current priorities include:</p>
    <ul>
      <li><strong>Improving detection accuracy and improving human review workflows</strong> &mdash; <em>[Underway]</em> Manual ground-truth labelling against source documentation is underway to empirically tune the semantic matching thresholds. The goal is reliable, automated linking of models to techniques with transparent confidence levels. I'm also running post-labelling analysis to optimise the technique and category taxonomy to minimise overlap (and concept confusability) by the automated linking workflow. I'm also making improvements to the human review user interface with a view to optimising the linking output review workflow &mdash; including capture of link origination sources (NLU/LLM/Human) &mdash; which will lead into simpler feedback mechanisms (including community-based contributions).</li>
      <li><strong>Reported Safety Incidents</strong> &mdash; <em>[Planned]</em> Reported safety incidents linked to models, with a mechanism for public users to submit incidents as well as performing automated scans for them. Recent issues with Grok stand out as an excellent example, as do situations like ChatGPT encouraging risky/dangerous behaviours.</li>
    </ul>

    <hr>

    <h2>Documentation</h2>

    <h3>Data Sources</h3>
    <p>This notebook fetches live data from the following GitHub repository endpoints:</p>
    <ul>
      <li><strong>Evidence:</strong> <code>evidence.json</code> &mdash; Points at sources of documentation (and soon, third party analysis) for models. This is used by <code>/scripts/ingest_universal.py</code> to map techniques to models. Metadata for the document in evidence.json lists the provider and model versions to which it relates.</li>
      <li><strong>Techniques:</strong> <code>techniques.json</code> &mdash; Catalog of safety techniques and methodologies. These are expanded with additional semantic content (descriptions, alternative equivalent terminology, etc) to support the automation step which correlates evidence (and related models) with techniques using NLU libraries.</li>
      <li><strong>Providers:</strong> <code>providers.json</code> &mdash; LLM provider names.</li>
      <li><strong>Models:</strong> <code>models.json</code> &mdash; Model versions.</li>
    </ul>

    <h3>Methodology</h3>
    <ul>
      <li><strong>Data Processing:</strong> Documentation sources are converted to flat file using Python (BeautifulSoup), then matched against the semantic concepts captured in techniques.json using vectorization: it uses a Bi-Encoder model (all-mpnet-base-v2) to convert the descriptions of these techniques into mathematical vector embeddings.</li>
      <li><strong>Confidence:</strong> This is calculated via a Cross-Encoder model (nli-deberta-v3-small) trained on Natural Language Inference (NLI). High Confidence: &gt; 80% entailment score, Medium Confidence: &gt; 50% entailment score.</li>
      <li><strong>Filtering:</strong> Multi-dimensional filtering across providers, techniques, ratings, and free-text search.</li>
    </ul>

    <h3>Usage Examples</h3>
    <h4>Basic Filtering</h4>
    <ol>
      <li>Select a provider from the dropdown to focus on specific implementations</li>
      <li>Choose a technique type to analyse particular safety approaches</li>
      <li>Adjust the minimum rating slider to filter by confidence threshold</li>
      <li>Use the search box for free-text filtering across descriptions</li>
    </ol>
    <h4>Advanced Analytics</h4>
    <p><strong>Provider Comparison:</strong> Compare safety mechanism adoption across providers</p>
    <h4>Data Export</h4>
    <ul>
      <li><strong>JSON Export:</strong> Full structured data with all fields and metadata</li>
      <li><strong>CSV Export:</strong> Tabular format suitable for spreadsheet analysis</li>
      <li><strong>Configuration Export:</strong> Save current filter settings for reproducibility</li>
    </ul>

    <hr>

    <footer>
      <strong>Repository:</strong> <a href="https://github.com/sashaagafonoff/LLM-Safety-Mechanisms">LLM Safety Mechanisms</a> &middot;
      <strong>License:</strong> MIT &middot;
      <strong>Maintainer:</strong> Sasha Agafonoff
    </footer>
  </main>

  <script type="importmap">
  {
    "imports": {
      "htl": "https://esm.sh/htl@0.3.1",
      "d3": "https://esm.sh/d3@7.9.0"
    }
  }
  </script>

  <script type="module">
    import * as d3 from "d3";
    import {html} from "htl";

    // --- Component Imports ---
    import {buildDataset, applyFilters} from "./components/data-pipeline.js";
    import {generateColorSchemes} from "./components/color-schemes.js";
    import {createFilterForm} from "./components/filters.js";
    import {unifiedChartConfig, buildUnifiedChartData, createUnifiedChartLayouts, validateUnifiedChartLayout} from "./components/unified-chart-data.js";
    import {createUnifiedChart} from "./components/unified-chart.js";
    import {createSunburstChart} from "./components/sunburst-chart.js";
    import {lifecycleConfig, buildLifecycleChartData} from "./components/lifecycle-data.js";
    import {createLifecycleChart} from "./components/lifecycle-chart.js";
    import {networkConfig, buildNetworkGraph, positionGraph, computeAutoLayout, validateNetworkLayout} from "./components/network-data.js";
    import {createNetworkViz} from "./components/network-viz.js";
    import {createDataQualityReport} from "./components/data-quality.js";

    // --- Data Loading ---
    const ghBase = "https://raw.githubusercontent.com/sashaagafonoff/LLM-Safety-Mechanisms/main/data";
    const fetchJson = (name) => fetch(`${ghBase}/${name}`).then((r) => r.json());

    const [evidence, techniques, categories, techniqueMap, models, providers, lifecycle, netLayout] =
      await Promise.all([
        fetchJson("evidence.json"),
        fetchJson("techniques.json"),
        fetchJson("categories.json"),
        fetchJson("model_technique_map.json"),
        fetchJson("models.json"),
        fetchJson("providers.json"),
        fetchJson("model_lifecycle.json"),
        fetch("./data/network-layout.json").then((r) => r.json())
      ]);

    // --- Build Dataset ---
    const data = buildDataset(evidence, techniques, categories, techniqueMap, models, providers, lifecycle);
    const {categoryColors, providerColors} = generateColorSchemes(data.raw.categories, data.raw.providers, d3);

    // --- Filter Setup ---
    const filterForm = createFilterForm(data, d3);
    document.getElementById("filter-container").appendChild(filterForm);
    let filteredData = applyFilters(data, filterForm.value || {});

    // --- Render helper ---
    function renderInto(id, fn) {
      const el = document.getElementById(id);
      el.innerHTML = "";
      const result = fn();
      if (result) el.appendChild(result);
    }

    // --- Filter-dependent charts ---
    function renderFiltered() {
      renderInto("network-chart", () => {
        const chartData = buildUnifiedChartData(data, filteredData, categoryColors, providerColors, d3);
        const layouts = createUnifiedChartLayouts(d3);
        const validatedLayout = validateUnifiedChartLayout(chartData, layouts);
        return createUnifiedChart(chartData, unifiedChartConfig, layouts, validatedLayout, d3);
      });

      renderInto("sunburst-chart", () => createSunburstChart(data, filteredData, categoryColors, d3));

      renderSummaryTable();
    }

    function renderSummaryTable() {
      const container = document.getElementById("summary-table");
      container.innerHTML = "";

      // --- Overview metrics ---
      const linkedTechniques = new Set(filteredData.map((d) => d.technique));
      const linkedCategories = new Set(filteredData.map((d) => d.category));
      const linkedProviders = new Set(filteredData.map((d) => d.provider));

      const overview = document.createElement("div");
      overview.innerHTML = `
        <p><strong>Total Records:</strong> ${filteredData.length}</p>
        <table class="summary-table" style="max-width: 500px; margin-bottom: 16px;">
          <thead><tr><th>Metric</th><th>Currently Linked</th><th>Total in Dataset</th></tr></thead>
          <tbody>
            <tr><td>Techniques</td><td>${linkedTechniques.size}</td><td>${data.raw.techniques.length}</td></tr>
            <tr><td>Categories</td><td>${linkedCategories.size}</td><td>${data.raw.categories.length}</td></tr>
            <tr><td>Providers</td><td>${linkedProviders.size}</td><td>${data.raw.providers.length}</td></tr>
          </tbody>
        </table>
        <p><strong>Active Categories:</strong> ${[...linkedCategories].sort().join(", ")}</p>
        <p><strong>Active Providers:</strong> ${[...linkedProviders].sort().join(", ")}</p>
      `;
      container.appendChild(overview);

      // --- Per-provider breakdown ---
      const stats = {};
      filteredData.forEach((d) => {
        if (!stats[d.provider]) stats[d.provider] = {provider: d.provider, techniques: new Set(), high: 0, medium: 0, low: 0};
        stats[d.provider].techniques.add(d.technique);
        if (d.confidence === "High") stats[d.provider].high++;
        else if (d.confidence === "Medium") stats[d.provider].medium++;
        else stats[d.provider].low++;
      });

      const rows = Object.values(stats)
        .map((s) => ({provider: s.provider, techniques: s.techniques.size, high: s.high, medium: s.medium, low: s.low, total: s.high + s.medium + s.low}))
        .sort((a, b) => b.total - a.total);

      const table = document.createElement("table");
      table.className = "summary-table";
      table.innerHTML = "<thead><tr><th>Provider</th><th># Techniques</th><th>High</th><th>Medium</th><th>Low</th><th>Total Evidence</th></tr></thead>";
      const tbody = document.createElement("tbody");
      for (const r of rows) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${r.provider}</td><td>${r.techniques}</td><td>${r.high}</td><td>${r.medium}</td><td>${r.low}</td><td>${r.total}</td>`;
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      container.appendChild(table);
    }

    // --- Static charts (render once) ---
    function renderStatic() {
      renderInto("lifecycle-chart", () => {
        const lifecycleChartData = buildLifecycleChartData(data);
        return createLifecycleChart(data, lifecycleChartData, lifecycleConfig, d3);
      });

      renderInto("doc-network", () => {
        const netGraph = buildNetworkGraph(data);
        const validatedNetLayout = validateNetworkLayout(netGraph, netLayout);
        const autoLayout = computeAutoLayout(netGraph, networkConfig, d3);
        const positioned = positionGraph(netGraph, validatedNetLayout, networkConfig, d3);
        return createNetworkViz(positioned, validatedNetLayout, autoLayout, networkConfig, providerColors, d3);
      });

      renderInto("data-quality", () => createDataQualityReport(data, providerColors));

      renderInto("export-panel", () => {
        return html`<div style="display: flex; gap: 10px;">
          <button onclick=${() => downloadFile("json")}>Export Filtered JSON</button>
          <button onclick=${() => downloadFile("csv")}>Export Filtered CSV</button>
        </div>`;
      });
    }

    function downloadFile(format) {
      let blob, filename;
      if (format === "json") {
        blob = new Blob([JSON.stringify(filteredData, null, 2)], {type: "application/json"});
        filename = "filtered-safety-data.json";
      } else {
        const headers = ["provider", "technique", "category", "confidence", "model", "source"];
        const csvRows = filteredData.map((d) => headers.map((h) => JSON.stringify(d[h] || "")).join(","));
        blob = new Blob([[headers.join(","), ...csvRows].join("\n")], {type: "text/csv"});
        filename = "filtered-safety-data.csv";
      }
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // --- Wire reactivity ---
    filterForm.addEventListener("input", () => {
      filteredData = applyFilters(data, filterForm.value || {});
      renderFiltered();
    });

    // --- Initial render ---
    renderFiltered();
    renderStatic();
  </script>
</body>
</html>
